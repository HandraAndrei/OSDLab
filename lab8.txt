diff --git a/lab7.txt b/lab7.txt
new file mode 100644
index 0000000..c5222f6
--- /dev/null
+++ b/lab7.txt
@@ -0,0 +1,137 @@
+diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
+index 0cccd74..4ccbbeb 100644
+--- a/src/HAL9000/src/isr.c
++++ b/src/HAL9000/src/isr.c
+@@ -143,6 +143,16 @@ _IsrExceptionHandler(
+         LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
+     }
+ 
++    if (!exceptionHandled)
++    {
++        if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
++        {
++            PPROCESS currProcess = GetCurrentProcess();
++            LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
++            ProcessTerminate(currProcess);
++        }
++    }
++
+     // no use in logging if we solved the problem
+     if (!exceptionHandled)
+     {
+diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
+index 1576f7f..0464491 100644
+--- a/src/HAL9000/src/syscall.c
++++ b/src/HAL9000/src/syscall.c
+@@ -7,6 +7,8 @@
+ #include "mmu.h"
+ #include "process_internal.h"
+ #include "dmp_cpu.h"
++#include "thread.h"
++#include "thread_internal.h"
+ 
+ extern void SyscallEntry();
+ 
+@@ -68,6 +70,20 @@ SyscallHandler(
+             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
+             break;
+         // STUDENT TODO: implement the rest of the syscalls
++        case SyscallIdProcessExit:
++            status = SyscallProcessExit((STATUS)*pSyscallParameters);
++            break;
++        case SyscallIdThreadExit:
++            status = SyscallThreadExit((STATUS)*pSyscallParameters);
++            break;
++        case SyscallIdFileWrite:
++            status = SyscallFileWrite(
++                (UM_HANDLE)pSyscallParameters[0],
++                (PVOID)pSyscallParameters[1],
++                (QWORD)pSyscallParameters[2],
++                (QWORD*)pSyscallParameters[3]
++                );
++            break;
+         default:
+             LOG_ERROR("Unimplemented syscall called from User-space!\n");
+             status = STATUS_UNSUPPORTED;
+@@ -169,4 +185,47 @@ SyscallValidateInterface(
+     return STATUS_SUCCESS;
+ }
+ 
+-// STUDENT TODO: implement the rest of the syscalls
+\ No newline at end of file
++// STUDENT TODO: implement the rest of the syscalls
++STATUS
++SyscallFileWrite(
++    IN  UM_HANDLE                   FileHandle,
++    IN_READS_BYTES(BytesToWrite)
++     PVOID                       Buffer,
++    IN  QWORD                       BytesToWrite,
++    OUT QWORD * BytesWritten
++)
++{
++    if (BytesWritten == NULL) {
++        return STATUS_UNSUCCESSFUL;
++        
++    }
++    
++    if (FileHandle == UM_FILE_HANDLE_STDOUT) {
++        *BytesWritten = BytesToWrite;
++        LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
++        return STATUS_SUCCESS;
++    }
++    *BytesWritten = BytesToWrite;
++    return STATUS_SUCCESS;
++}
++
++STATUS
++SyscallThreadExit(
++    IN  STATUS                      ExitStatus
++)
++{
++    ThreadExit(ExitStatus);
++    return STATUS_SUCCESS;
++}
++
++STATUS
++SyscallProcessExit(
++    IN      STATUS                  ExitStatus
++)
++{
++    PPROCESS Process;
++    Process = GetCurrentProcess();
++    Process->TerminationStatus = ExitStatus;
++    ProcessTerminate(Process);
++    return STATUS_SUCCESS;
++}
+\ No newline at end of file
+diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
+index 780a0bc..9e03560 100644
+--- a/src/HAL9000/src/system.c
++++ b/src/HAL9000/src/system.c
+@@ -77,8 +77,8 @@ SystemInit(
+                   TRUE
+                   );
+                   */
+-    LogSystemInit(LogLevelTrace,
+-        LogComponentUserMode,
++    LogSystemInit(LogLevelInfo,
++        LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode | LogComponentMmu,
+         TRUE
+     );
+ 
+diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
+index a70a2cb..d5b5860 100644
+--- a/src/HAL9000/src/vmm.c
++++ b/src/HAL9000/src/vmm.c
+@@ -269,7 +269,10 @@ VmmMapMemoryInternal(
+     ctx.Uncacheable = Uncacheable;
+ 
+     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
+-
++    if (!_VmIsKernelAddress(BaseAddress)) {
++        LOG("Will map virtual address 0x%X to physical address 0x%X\n",
++            BaseAddress, PhysicalAddress);
++    }
+     _VmWalkPagingTables(cr3,
+                         BaseAddress,
+                         Size,
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index 0464491..a625f9d 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -84,6 +84,32 @@ SyscallHandler(
                 (QWORD*)pSyscallParameters[3]
                 );
             break;
+        case SyscallIdThreadCreate:
+            status = SyscallThreadCreate(
+                (PFUNC_ThreadStart)pSyscallParameters[0],
+                (PVOID)pSyscallParameters[1],
+                (UM_HANDLE*)pSyscallParameters[2]);
+            break;
+        case SyscallIdThreadGetTid:
+            status = SyscallThreadGetTid(
+                (UM_HANDLE)pSyscallParameters[0],
+                (TID*)pSyscallParameters[1]);
+            break;
+        case SyscallIdProcessGetPid:
+            status = SyscallProcessGetPid(
+                (UM_HANDLE)pSyscallParameters[0],
+                (PID*)pSyscallParameters[1]);
+            break;
+        case SyscallIdThreadWaitForTermination :
+            status = SyscallThreadWaitForTermination(
+                (UM_HANDLE)pSyscallParameters[0],
+                (STATUS*)pSyscallParameters[1]);
+            break;
+        case SyscallIdThreadCloseHandle :
+            status = SyscallThreadCloseHandle(
+                (UM_HANDLE)pSyscallParameters[0]);
+            break;
+
         default:
             LOG_ERROR("Unimplemented syscall called from User-space!\n");
             status = STATUS_UNSUPPORTED;
@@ -218,6 +244,55 @@ SyscallThreadExit(
     return STATUS_SUCCESS;
 }
 
+STATUS
+SyscallThreadCreate(
+    IN      PFUNC_ThreadStart       StartFunction,
+    IN_OPT  PVOID                   Context,
+    OUT     UM_HANDLE* ThreadHandle
+) {
+    PTHREAD thread = NULL;
+    if (StartFunction == NULL) {
+        return STATUS_UNSUCCESSFUL;
+    }
+    ThreadCreate("name", ThreadPriorityDefault, StartFunction, Context, &thread);
+    ThreadHandle = (UM_HANDLE*)thread;
+    return STATUS_SUCCESS;
+}
+STATUS
+SyscallThreadGetTid(
+    IN_OPT  UM_HANDLE               ThreadHandle,
+    OUT     TID* ThreadId
+) {
+    *ThreadId = ThreadGetId((PTHREAD)ThreadHandle);
+    return STATUS_SUCCESS;
+}
+STATUS
+SyscallThreadWaitForTermination(
+    IN      UM_HANDLE               ThreadHandle,
+    OUT     STATUS* TerminationStatus
+) {
+    ThreadWaitForTermination((PTHREAD)ThreadHandle,&TerminationStatus);
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallThreadCloseHandle(
+    IN      UM_HANDLE               ThreadHandle
+) {
+    ThreadCloseHandle((PTHREAD)ThreadHandle);
+    return STATUS_SUCCESS;
+}
+
+
+STATUS
+SyscallProcessGetPid(
+    IN_OPT  UM_HANDLE               ProcessHandle,
+    OUT     PID* ProcessId
+) {
+    *ProcessId = ProcessGetId((PPROCESS)ProcessHandle);
+    return STATUS_SUCCESS;
+}
+
 STATUS
 SyscallProcessExit(
     IN      STATUS                  ExitStatus
