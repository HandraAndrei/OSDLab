diff --git a/lab7.txt b/lab7.txt
deleted file mode 100644
index c5222f6..0000000
--- a/lab7.txt
+++ /dev/null
@@ -1,137 +0,0 @@
-diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
-index 0cccd74..4ccbbeb 100644
---- a/src/HAL9000/src/isr.c
-+++ b/src/HAL9000/src/isr.c
-@@ -143,6 +143,16 @@ _IsrExceptionHandler(
-         LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
-     }
- 
-+    if (!exceptionHandled)
-+    {
-+        if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
-+        {
-+            PPROCESS currProcess = GetCurrentProcess();
-+            LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
-+            ProcessTerminate(currProcess);
-+        }
-+    }
-+
-     // no use in logging if we solved the problem
-     if (!exceptionHandled)
-     {
-diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
-index 1576f7f..0464491 100644
---- a/src/HAL9000/src/syscall.c
-+++ b/src/HAL9000/src/syscall.c
-@@ -7,6 +7,8 @@
- #include "mmu.h"
- #include "process_internal.h"
- #include "dmp_cpu.h"
-+#include "thread.h"
-+#include "thread_internal.h"
- 
- extern void SyscallEntry();
- 
-@@ -68,6 +70,20 @@ SyscallHandler(
-             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
-             break;
-         // STUDENT TODO: implement the rest of the syscalls
-+        case SyscallIdProcessExit:
-+            status = SyscallProcessExit((STATUS)*pSyscallParameters);
-+            break;
-+        case SyscallIdThreadExit:
-+            status = SyscallThreadExit((STATUS)*pSyscallParameters);
-+            break;
-+        case SyscallIdFileWrite:
-+            status = SyscallFileWrite(
-+                (UM_HANDLE)pSyscallParameters[0],
-+                (PVOID)pSyscallParameters[1],
-+                (QWORD)pSyscallParameters[2],
-+                (QWORD*)pSyscallParameters[3]
-+                );
-+            break;
-         default:
-             LOG_ERROR("Unimplemented syscall called from User-space!\n");
-             status = STATUS_UNSUPPORTED;
-@@ -169,4 +185,47 @@ SyscallValidateInterface(
-     return STATUS_SUCCESS;
- }
- 
--// STUDENT TODO: implement the rest of the syscalls
-\ No newline at end of file
-+// STUDENT TODO: implement the rest of the syscalls
-+STATUS
-+SyscallFileWrite(
-+    IN  UM_HANDLE                   FileHandle,
-+    IN_READS_BYTES(BytesToWrite)
-+     PVOID                       Buffer,
-+    IN  QWORD                       BytesToWrite,
-+    OUT QWORD * BytesWritten
-+)
-+{
-+    if (BytesWritten == NULL) {
-+        return STATUS_UNSUCCESSFUL;
-+        
-+    }
-+    
-+    if (FileHandle == UM_FILE_HANDLE_STDOUT) {
-+        *BytesWritten = BytesToWrite;
-+        LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
-+        return STATUS_SUCCESS;
-+    }
-+    *BytesWritten = BytesToWrite;
-+    return STATUS_SUCCESS;
-+}
-+
-+STATUS
-+SyscallThreadExit(
-+    IN  STATUS                      ExitStatus
-+)
-+{
-+    ThreadExit(ExitStatus);
-+    return STATUS_SUCCESS;
-+}
-+
-+STATUS
-+SyscallProcessExit(
-+    IN      STATUS                  ExitStatus
-+)
-+{
-+    PPROCESS Process;
-+    Process = GetCurrentProcess();
-+    Process->TerminationStatus = ExitStatus;
-+    ProcessTerminate(Process);
-+    return STATUS_SUCCESS;
-+}
-\ No newline at end of file
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index 780a0bc..9e03560 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -77,8 +77,8 @@ SystemInit(
-                   TRUE
-                   );
-                   */
--    LogSystemInit(LogLevelTrace,
--        LogComponentUserMode,
-+    LogSystemInit(LogLevelInfo,
-+        LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode | LogComponentMmu,
-         TRUE
-     );
- 
-diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
-index a70a2cb..d5b5860 100644
---- a/src/HAL9000/src/vmm.c
-+++ b/src/HAL9000/src/vmm.c
-@@ -269,7 +269,10 @@ VmmMapMemoryInternal(
-     ctx.Uncacheable = Uncacheable;
- 
-     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
--
-+    if (!_VmIsKernelAddress(BaseAddress)) {
-+        LOG("Will map virtual address 0x%X to physical address 0x%X\n",
-+            BaseAddress, PhysicalAddress);
-+    }
-     _VmWalkPagingTables(cr3,
-                         BaseAddress,
-                         Size,
diff --git a/src/HAL9000/headers.rar b/src/HAL9000/headers.rar
new file mode 100644
index 0000000..0592108
Binary files /dev/null and b/src/HAL9000/headers.rar differ
diff --git a/src/HAL9000/src.rar b/src/HAL9000/src.rar
new file mode 100644
index 0000000..8a9939c
Binary files /dev/null and b/src/HAL9000/src.rar differ
diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
index d0b254f..fa5a0ee 100644
--- a/src/HAL9000/src/cmd_interpreter.c
+++ b/src/HAL9000/src/cmd_interpreter.c
@@ -13,6 +13,9 @@
 #include "cmd_net_helper.h"
 #include "cmd_basic.h"
 #include "boot_module.h"
+#include "iomu.h"
+#include "process_internal.h"
+
 
 #pragma warning(push)
 
@@ -203,6 +206,25 @@ CmdRun(
     DWORD bytesRead;
 
     bytesRead = 0;
+    
+    for (DWORD i = 0; i < 16; ++i)
+    {
+        STATUS status;
+        PPROCESS pProcess;
+        char fullPath[MAX_PATH];
+
+        pProcess = NULL;
+
+        status = snprintf(fullPath, MAX_PATH, "%sAPPLIC~1\\VirtualAllocNormal.exe",
+            IomuGetSystemPartitionPath());
+        ASSERT(SUCCEEDED(status));
+
+        status = ProcessCreate(fullPath, NULL, &pProcess);
+        ASSERT(SUCCEEDED(status));
+    }
+    
+    
+    
 
     exit = _CmdExecuteModuleCommands();
     while (!exit)
diff --git a/src/HAL9000/src/pmm.c b/src/HAL9000/src/pmm.c
index 2347074..a064cb4 100644
--- a/src/HAL9000/src/pmm.c
+++ b/src/HAL9000/src/pmm.c
@@ -3,6 +3,8 @@
 #include "int15.h"
 #include "bitmap.h"
 #include "synch.h"
+#include"thread_internal.h"
+#include "process.h"
 
 typedef struct _MEMORY_REGION_LIST
 {
@@ -180,6 +182,21 @@ PmmReserveMemoryEx(
 
     LockRelease( &m_pmmData.AllocationLock, oldState);
 
+    PTHREAD pThread = GetCurrentThread();
+    PPROCESS pCurrentProcess = NULL;
+    BOOLEAN bSystemProcess;
+
+    if (pThread != NULL)
+    {
+        pCurrentProcess = pThread->Process;
+    }
+
+    bSystemProcess = (pCurrentProcess == NULL) || ProcessIsSystem(pCurrentProcess);
+
+    LOG("Reserved physical frames from 0x%X of size 0x%X on behalf of [%s] process\n",
+        idx * PAGE_SIZE, ((QWORD)NoOfFrames * PAGE_SIZE),
+        bSystemProcess ? "SYSTEM" : ProcessGetName(pCurrentProcess));
+
     return (PHYSICAL_ADDRESS) ( (QWORD) idx * PAGE_SIZE );
 }
 
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index a625f9d..dd42248 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -9,6 +9,7 @@
 #include "dmp_cpu.h"
 #include "thread.h"
 #include "thread_internal.h"
+#include "vmm.h"
 
 extern void SyscallEntry();
 
@@ -84,30 +85,16 @@ SyscallHandler(
                 (QWORD*)pSyscallParameters[3]
                 );
             break;
-        case SyscallIdThreadCreate:
-            status = SyscallThreadCreate(
-                (PFUNC_ThreadStart)pSyscallParameters[0],
-                (PVOID)pSyscallParameters[1],
-                (UM_HANDLE*)pSyscallParameters[2]);
-            break;
-        case SyscallIdThreadGetTid:
-            status = SyscallThreadGetTid(
-                (UM_HANDLE)pSyscallParameters[0],
-                (TID*)pSyscallParameters[1]);
-            break;
-        case SyscallIdProcessGetPid:
-            status = SyscallProcessGetPid(
-                (UM_HANDLE)pSyscallParameters[0],
-                (PID*)pSyscallParameters[1]);
-            break;
-        case SyscallIdThreadWaitForTermination :
-            status = SyscallThreadWaitForTermination(
-                (UM_HANDLE)pSyscallParameters[0],
-                (STATUS*)pSyscallParameters[1]);
-            break;
-        case SyscallIdThreadCloseHandle :
-            status = SyscallThreadCloseHandle(
-                (UM_HANDLE)pSyscallParameters[0]);
+        case SyscallIdVirtualAlloc:
+            status = SyscallVirtualAlloc(
+                (PVOID)pSyscallParameters[0],
+                (QWORD)pSyscallParameters[1],
+                (VMM_ALLOC_TYPE)pSyscallParameters[2],
+                (PAGE_RIGHTS)pSyscallParameters[3],
+                (UM_HANDLE)pSyscallParameters[4],
+                (QWORD)pSyscallParameters[5],
+                (PVOID)pSyscallParameters[6]
+            );
             break;
 
         default:
@@ -244,55 +231,6 @@ SyscallThreadExit(
     return STATUS_SUCCESS;
 }
 
-STATUS
-SyscallThreadCreate(
-    IN      PFUNC_ThreadStart       StartFunction,
-    IN_OPT  PVOID                   Context,
-    OUT     UM_HANDLE* ThreadHandle
-) {
-    PTHREAD thread = NULL;
-    if (StartFunction == NULL) {
-        return STATUS_UNSUCCESSFUL;
-    }
-    ThreadCreate("name", ThreadPriorityDefault, StartFunction, Context, &thread);
-    ThreadHandle = (UM_HANDLE*)thread;
-    return STATUS_SUCCESS;
-}
-STATUS
-SyscallThreadGetTid(
-    IN_OPT  UM_HANDLE               ThreadHandle,
-    OUT     TID* ThreadId
-) {
-    *ThreadId = ThreadGetId((PTHREAD)ThreadHandle);
-    return STATUS_SUCCESS;
-}
-STATUS
-SyscallThreadWaitForTermination(
-    IN      UM_HANDLE               ThreadHandle,
-    OUT     STATUS* TerminationStatus
-) {
-    ThreadWaitForTermination((PTHREAD)ThreadHandle,&TerminationStatus);
-    return STATUS_SUCCESS;
-}
-
-STATUS
-SyscallThreadCloseHandle(
-    IN      UM_HANDLE               ThreadHandle
-) {
-    ThreadCloseHandle((PTHREAD)ThreadHandle);
-    return STATUS_SUCCESS;
-}
-
-
-STATUS
-SyscallProcessGetPid(
-    IN_OPT  UM_HANDLE               ProcessHandle,
-    OUT     PID* ProcessId
-) {
-    *ProcessId = ProcessGetId((PPROCESS)ProcessHandle);
-    return STATUS_SUCCESS;
-}
-
 STATUS
 SyscallProcessExit(
     IN      STATUS                  ExitStatus
@@ -303,4 +241,22 @@ SyscallProcessExit(
     Process->TerminationStatus = ExitStatus;
     ProcessTerminate(Process);
     return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallVirtualAlloc(
+    IN_OPT      PVOID                   BaseAddress,
+    IN          QWORD                   Size,
+    IN          VMM_ALLOC_TYPE          AllocType,
+    IN          PAGE_RIGHTS             PageRights,
+    IN_OPT      UM_HANDLE               FileHandle,
+    IN_OPT      QWORD                   Key,
+    OUT         PVOID* AllocatedAddress
+)
+{
+    UNREFERENCED_PARAMETER(Key);
+    UNREFERENCED_PARAMETER(FileHandle)
+    PVOID address = VmmAllocRegionEx(BaseAddress,Size,AllocType,PageRights,FALSE,NULL,NULL,NULL,NULL);
+    *AllocatedAddress = address;
+    return STATUS_SUCCESS;
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
index d5b5860..f3d9df2 100644
--- a/src/HAL9000/src/vmm.c
+++ b/src/HAL9000/src/vmm.c
@@ -571,6 +571,8 @@ VmmAllocRegionEx(
             LOG_FUNC_ERROR("VmReservationSpaceAllocRegion", status);
             __leave;
         }
+        LOG("Allocating for VaSpace at 0x%X, a memory region from 0x%X of size 0x%X\n",
+            pVaSpace, pBaseAddress, alignedSize);
         ASSERT(NULL != pBaseAddress);
 
         if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY))
