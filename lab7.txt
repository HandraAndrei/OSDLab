diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
index 0cccd74..4ccbbeb 100644
--- a/src/HAL9000/src/isr.c
+++ b/src/HAL9000/src/isr.c
@@ -143,6 +143,16 @@ _IsrExceptionHandler(
         LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
     }
 
+    if (!exceptionHandled)
+    {
+        if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
+        {
+            PPROCESS currProcess = GetCurrentProcess();
+            LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
+            ProcessTerminate(currProcess);
+        }
+    }
+
     // no use in logging if we solved the problem
     if (!exceptionHandled)
     {
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index 1576f7f..0464491 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -7,6 +7,8 @@
 #include "mmu.h"
 #include "process_internal.h"
 #include "dmp_cpu.h"
+#include "thread.h"
+#include "thread_internal.h"
 
 extern void SyscallEntry();
 
@@ -68,6 +70,20 @@ SyscallHandler(
             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
             break;
         // STUDENT TODO: implement the rest of the syscalls
+        case SyscallIdProcessExit:
+            status = SyscallProcessExit((STATUS)*pSyscallParameters);
+            break;
+        case SyscallIdThreadExit:
+            status = SyscallThreadExit((STATUS)*pSyscallParameters);
+            break;
+        case SyscallIdFileWrite:
+            status = SyscallFileWrite(
+                (UM_HANDLE)pSyscallParameters[0],
+                (PVOID)pSyscallParameters[1],
+                (QWORD)pSyscallParameters[2],
+                (QWORD*)pSyscallParameters[3]
+                );
+            break;
         default:
             LOG_ERROR("Unimplemented syscall called from User-space!\n");
             status = STATUS_UNSUPPORTED;
@@ -169,4 +185,47 @@ SyscallValidateInterface(
     return STATUS_SUCCESS;
 }
 
-// STUDENT TODO: implement the rest of the syscalls
\ No newline at end of file
+// STUDENT TODO: implement the rest of the syscalls
+STATUS
+SyscallFileWrite(
+    IN  UM_HANDLE                   FileHandle,
+    IN_READS_BYTES(BytesToWrite)
+     PVOID                       Buffer,
+    IN  QWORD                       BytesToWrite,
+    OUT QWORD * BytesWritten
+)
+{
+    if (BytesWritten == NULL) {
+        return STATUS_UNSUCCESSFUL;
+        
+    }
+    
+    if (FileHandle == UM_FILE_HANDLE_STDOUT) {
+        *BytesWritten = BytesToWrite;
+        LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
+        return STATUS_SUCCESS;
+    }
+    *BytesWritten = BytesToWrite;
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallThreadExit(
+    IN  STATUS                      ExitStatus
+)
+{
+    ThreadExit(ExitStatus);
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallProcessExit(
+    IN      STATUS                  ExitStatus
+)
+{
+    PPROCESS Process;
+    Process = GetCurrentProcess();
+    Process->TerminationStatus = ExitStatus;
+    ProcessTerminate(Process);
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index 780a0bc..9e03560 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -77,8 +77,8 @@ SystemInit(
                   TRUE
                   );
                   */
-    LogSystemInit(LogLevelTrace,
-        LogComponentUserMode,
+    LogSystemInit(LogLevelInfo,
+        LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode | LogComponentMmu,
         TRUE
     );
 
diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
index a70a2cb..d5b5860 100644
--- a/src/HAL9000/src/vmm.c
+++ b/src/HAL9000/src/vmm.c
@@ -269,7 +269,10 @@ VmmMapMemoryInternal(
     ctx.Uncacheable = Uncacheable;
 
     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
-
+    if (!_VmIsKernelAddress(BaseAddress)) {
+        LOG("Will map virtual address 0x%X to physical address 0x%X\n",
+            BaseAddress, PhysicalAddress);
+    }
     _VmWalkPagingTables(cr3,
                         BaseAddress,
                         Size,
