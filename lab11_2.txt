diff --git a/Lab5.txt b/Lab5.txt
deleted file mode 100644
index f288152..0000000
--- a/Lab5.txt
+++ /dev/null
@@ -1,907 +0,0 @@
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index cec924b..ade0507 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
- set PATH_TO_VM_TOOLS=__EMPTY__
- set VOL_MOUNT_LETTER=__EMPTY__
- 
-+if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
- if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
- if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
- if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
- 
- goto end
- 
-+:config_DESKTOP-6K9VMO8
-+
-+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-+SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-+SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+goto end
-+
- :end
-\ No newline at end of file
-diff --git a/src/.gitignore b/src/.gitignore
-new file mode 100644
-index 0000000..a4d6d9c
---- /dev/null
-+++ b/src/.gitignore
-@@ -0,0 +1 @@
-+.vs/
-\ No newline at end of file
-diff --git a/src/HAL9000/HAL9000.vcxproj b/src/HAL9000/HAL9000.vcxproj
-index 0dd1641..f614446 100644
---- a/src/HAL9000/HAL9000.vcxproj
-+++ b/src/HAL9000/HAL9000.vcxproj
-@@ -181,6 +181,7 @@
-     </PostBuildEvent>
-   </ItemDefinitionGroup>
-   <ItemGroup>
-+    <ClCompile Include="semaphore.c" />
-     <ClCompile Include="src\acpi_interface.c" />
-     <ClCompile Include="src\acpi_osl.c" />
-     <ClCompile Include="src\ap_tramp.c" />
-@@ -366,6 +367,7 @@
-     <ClInclude Include="headers\um_application.h" />
-     <ClInclude Include="headers\vmm.h" />
-     <ClInclude Include="headers\vm_reservation_space.h" />
-+    <ClInclude Include="semaphore.h" />
-   </ItemGroup>
-   <ItemGroup>
-     <YASM Include="src\_mboot32.yasm">
-diff --git a/src/HAL9000/HAL9000.vcxproj.filters b/src/HAL9000/HAL9000.vcxproj.filters
-index f31d483..6797bc4 100644
---- a/src/HAL9000/HAL9000.vcxproj.filters
-+++ b/src/HAL9000/HAL9000.vcxproj.filters
-@@ -402,6 +402,9 @@
-     <ClCompile Include="src\test_process.c">
-       <Filter>Source Files\debug\test\userprog</Filter>
-     </ClCompile>
-+    <ClCompile Include="semaphore.c">
-+      <Filter>Source Files\executive</Filter>
-+    </ClCompile>
-   </ItemGroup>
-   <ItemGroup>
-     <ClInclude Include="headers\HAL9000.h">
-@@ -704,6 +707,9 @@
-     <ClInclude Include="headers\test_process.h">
-       <Filter>Header Files\debug\test\userprog</Filter>
-     </ClInclude>
-+    <ClInclude Include="semaphore.h">
-+      <Filter>Header Files\executive</Filter>
-+    </ClInclude>
-   </ItemGroup>
-   <ItemGroup>
-     <None Include="src\defines.yasm">
-diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-index be2588a..c5c6948 100644
---- a/src/HAL9000/headers/thread_internal.h
-+++ b/src/HAL9000/headers/thread_internal.h
-@@ -282,3 +282,5 @@ void
- ThreadSetPriority(
-     IN      THREAD_PRIORITY     NewPriority
-     );
-+
-+int getNrOfThreads();
-\ No newline at end of file
-diff --git a/src/HAL9000/semaphore.c b/src/HAL9000/semaphore.c
-new file mode 100644
-index 0000000..be8e67e
---- /dev/null
-+++ b/src/HAL9000/semaphore.c
-@@ -0,0 +1,77 @@
-+#include "HAL9000.h"
-+#include "thread_internal.h"
-+#include "semaphore.h"
-+
-+void
-+SemaphoreInit(
-+    OUT     PSEMAPHORE      Semaphore,
-+    IN      DWORD           InitialValue
-+) {
-+    ASSERT(NULL != Semaphore);
-+
-+    memzero(Semaphore, sizeof(SEMAPHORE));
-+
-+    LockInit(&Semaphore->SemaphoreLock);
-+
-+    InitializeListHead(&Semaphore->WaitingList);
-+
-+    Semaphore->Value = InitialValue;
-+
-+}
-+
-+void
-+SemaphoreDown(
-+    INOUT   PSEMAPHORE      Semaphore,
-+    IN      DWORD           Value
-+) {
-+    INTR_STATE dummystate;
-+    INTR_STATE oldState;
-+    PTHREAD pCurrentThread = GetCurrentThread();
-+
-+    ASSERT(NULL != Semaphore);
-+    ASSERT(NULL != pCurrentThread);
-+
-+    oldState = CpuIntrDisable();
-+
-+    LockAcquire(&Semaphore->SemaphoreLock, &dummystate);
-+    
-+    while (Semaphore->Value - Value < 0) {
-+        InsertTailList(&Semaphore->WaitingList, &pCurrentThread->ReadyList);
-+        ThreadTakeBlockLock();
-+        LockRelease(&Semaphore->SemaphoreLock, dummystate);
-+        ThreadBlock();
-+        LockAcquire(&Semaphore->SemaphoreLock, &dummystate);
-+    }
-+    
-+    Semaphore->Value = Semaphore->Value - Value;
-+    LockRelease(&Semaphore->SemaphoreLock, dummystate);
-+
-+    CpuIntrSetState(oldState);
-+    
-+}
-+
-+void
-+SemaphoreUp(
-+    INOUT   PSEMAPHORE      Semaphore,
-+    IN      DWORD           Value
-+) {
-+
-+    INTR_STATE oldState;
-+    PLIST_ENTRY pEntry = NULL;
-+
-+    ASSERT(NULL != Semaphore);
-+
-+    LockAcquire(&Semaphore->SemaphoreLock, &oldState);
-+
-+    Semaphore->Value += Value;
-+
-+    pEntry = RemoveHeadList(&Semaphore->WaitingList);
-+    if (pEntry != &Semaphore->WaitingList)
-+    {
-+        PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
-+        ThreadUnblock(pThread);
-+    }
-+
-+    LockRelease(&Semaphore->SemaphoreLock, oldState);
-+
-+}
-\ No newline at end of file
-diff --git a/src/HAL9000/semaphore.h b/src/HAL9000/semaphore.h
-new file mode 100644
-index 0000000..047c096
---- /dev/null
-+++ b/src/HAL9000/semaphore.h
-@@ -0,0 +1,34 @@
-+#pragma once
-+
-+#include "list.h"
-+#include "synch.h"
-+#include "HAL9000.h"
-+
-+
-+typedef struct _SEMAPHORE
-+{
-+    DWORD           Value;
-+    LOCK            SemaphoreLock;
-+
-+    _Guarded_by_(SemaphoreLock)
-+    LIST_ENTRY          WaitingList;
-+    // ... add more fields here ...
-+} SEMAPHORE, * PSEMAPHORE;
-+
-+void
-+SemaphoreInit(
-+    OUT     PSEMAPHORE      Semaphore,
-+    IN      DWORD           InitialValue
-+);
-+
-+void
-+SemaphoreDown(
-+    INOUT   PSEMAPHORE      Semaphore,
-+    IN      DWORD           Value
-+);
-+
-+void
-+SemaphoreUp(
-+    INOUT   PSEMAPHORE      Semaphore,
-+    IN      DWORD           Value
-+);
-\ No newline at end of file
-diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
-index a7810ff..750f290 100644
---- a/src/HAL9000/src/Entry64.c
-+++ b/src/HAL9000/src/Entry64.c
-@@ -58,6 +58,8 @@ Entry64(
-     DumpParameters(argv);
- 
-     status = SystemInit(argv);
-+    //LogSetLevel(LogLevelTrace);
-+    //LogSetTracedComponents(LogComponentThread);
-     ASSERT(SUCCEEDED(status));
- 
-     LOGL("InitSystem executed successfully\n");
-diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-index f794c95..d85c26c 100644
---- a/src/HAL9000/src/cmd_thread_helper.c
-+++ b/src/HAL9000/src/cmd_thread_helper.c
-@@ -128,7 +128,7 @@ void
-     STATUS status;
- 
-     ASSERT(NumberOfParameters == 0);
--
-+    LOG("Nr of Threads: %d", getNrOfThreads());
-     LOG("%7s", "TID|");
-     LOG("%20s", "Name|");
-     LOG("%5s", "Prio|");
-diff --git a/src/HAL9000/src/mutex.c b/src/HAL9000/src/mutex.c
-index 57db7e8..7b0bb58 100644
---- a/src/HAL9000/src/mutex.c
-+++ b/src/HAL9000/src/mutex.c
-@@ -105,6 +105,7 @@ MutexRelease(
-     else
-     {
-         Mutex->Holder = NULL;
-+        //here is the comment
-     }
- 
-     _Analysis_assume_lock_released_(*Mutex);
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index b0b436e..efc7155 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -70,7 +70,7 @@ SystemInit(
-     status = STATUS_SUCCESS;
-     pCpu = NULL;
- 
--    LogSystemInit(LogLevelInfo,
-+    LogSystemInit(LogLevelError,
-                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                   TRUE
-                   );
-@@ -247,6 +247,7 @@ SystemInit(
-     LOGL("Successfully intiialized system process!\n");
- 
-     status = ThreadSystemInitIdleForCurrentCPU();
-+    LogSetLevel(LogLevelInfo);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index b311f0c..46ebf9c 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -10,7 +10,7 @@
- #include "gdtmu.h"
- #include "pe_exports.h"
- 
--#define TID_INCREMENT               4
-+#define TID_INCREMENT               10
- 
- #define THREAD_TIME_SLICE           1
- 
-@@ -32,10 +32,17 @@ typedef struct _THREAD_SYSTEM_DATA
-     _Guarded_by_(AllThreadsLock)
-     LIST_ENTRY          AllThreadsList;
- 
-+    int                 nrOfThreads;
-+
-     LOCK                ReadyThreadsLock;
- 
-     _Guarded_by_(ReadyThreadsLock)
-     LIST_ENTRY          ReadyThreadsList;
-+
-+    //added for Threads projects
-+    _Guarded_by_(ReadyThreadsLock)
-+    THREAD_PRIORITY     RunningThreadsMinPriority;
-+
- } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
- 
- static THREAD_SYSTEM_DATA m_threadSystemData;
-@@ -121,6 +128,7 @@ _ThreadDereference(
-     INOUT   PTHREAD                 Thread
-     );
- 
-+
- static FUNC_FreeFunction            _ThreadDestroy;
- 
- static
-@@ -142,7 +150,7 @@ ThreadSystemPreinit(
- 
-     InitializeListHead(&m_threadSystemData.AllThreadsList);
-     LockInit(&m_threadSystemData.AllThreadsLock);
--
-+    m_threadSystemData.nrOfThreads = 0;
-     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-     LockInit(&m_threadSystemData.ReadyThreadsLock);
- }
-@@ -170,6 +178,7 @@ ThreadSystemInitMainForCurrentCPU(
-     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
- 
-     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-+    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("_ThreadInit", status );
-@@ -642,6 +651,9 @@ ThreadGetId(
- 
-     return (NULL != pThread) ? pThread->Id : 0;
- }
-+int getNrOfThreads() {
-+    return m_threadSystemData.nrOfThreads;
-+}
- 
- THREAD_PRIORITY
- ThreadGetPriority(
-@@ -798,6 +810,7 @@ _ThreadInit(
- 
-         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-+        m_threadSystemData.nrOfThreads++;
-         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-     }
-     __finally
-@@ -810,7 +823,7 @@ _ThreadInit(
-                 pThread = NULL;
-             }
-         }
--
-+        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-         *Thread = pThread;
- 
-         LOG_FUNC_END;
-@@ -1187,8 +1200,11 @@ _ThreadDestroy(
-     ASSERT(NULL != pThread);
-     ASSERT(NULL == Context);
- 
-+    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-+
-     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-     RemoveEntryList(&pThread->AllList);
-+    m_threadSystemData.nrOfThreads--;
-     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
- 
-     // This must be done before removing the thread from the process list, else
-diff --git a/src/Lab2.txt b/src/Lab2.txt
-new file mode 100644
-index 0000000..a21831e
---- /dev/null
-+++ b/src/Lab2.txt
-@@ -0,0 +1,129 @@
-+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-+index cec924b..ade0507 100644
-+--- a/postbuild/paths.cmd
-++++ b/postbuild/paths.cmd
-+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
-+ set PATH_TO_VM_TOOLS=__EMPTY__
-+ set VOL_MOUNT_LETTER=__EMPTY__
-+ 
-++if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
-+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
-+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
-+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-+@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
-+ 
-+ goto end
-+ 
-++:config_DESKTOP-6K9VMO8
-++
-++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-++SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-++SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-++SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-++SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-++goto end
-++
-+ :end
-+\ No newline at end of file
-+diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-+index be2588a..c5c6948 100644
-+--- a/src/HAL9000/headers/thread_internal.h
-++++ b/src/HAL9000/headers/thread_internal.h
-+@@ -282,3 +282,5 @@ void
-+ ThreadSetPriority(
-+     IN      THREAD_PRIORITY     NewPriority
-+     );
-++
-++int getNrOfThreads();
-+\ No newline at end of file
-+diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-+index f794c95..d85c26c 100644
-+--- a/src/HAL9000/src/cmd_thread_helper.c
-++++ b/src/HAL9000/src/cmd_thread_helper.c
-+@@ -128,7 +128,7 @@ void
-+     STATUS status;
-+ 
-+     ASSERT(NumberOfParameters == 0);
-+-
-++    LOG("Nr of Threads: %d", getNrOfThreads());
-+     LOG("%7s", "TID|");
-+     LOG("%20s", "Name|");
-+     LOG("%5s", "Prio|");
-+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-+index b311f0c..9472327 100644
-+--- a/src/HAL9000/src/thread.c
-++++ b/src/HAL9000/src/thread.c
-+@@ -10,7 +10,7 @@
-+ #include "gdtmu.h"
-+ #include "pe_exports.h"
-+ 
-+-#define TID_INCREMENT               4
-++#define TID_INCREMENT               10
-+ 
-+ #define THREAD_TIME_SLICE           1
-+ 
-+@@ -32,6 +32,8 @@ typedef struct _THREAD_SYSTEM_DATA
-+     _Guarded_by_(AllThreadsLock)
-+     LIST_ENTRY          AllThreadsList;
-+ 
-++    int                 nrOfThreads;
-++
-+     LOCK                ReadyThreadsLock;
-+ 
-+     _Guarded_by_(ReadyThreadsLock)
-+@@ -121,6 +123,7 @@ _ThreadDereference(
-+     INOUT   PTHREAD                 Thread
-+     );
-+ 
-++
-+ static FUNC_FreeFunction            _ThreadDestroy;
-+ 
-+ static
-+@@ -142,7 +145,7 @@ ThreadSystemPreinit(
-+ 
-+     InitializeListHead(&m_threadSystemData.AllThreadsList);
-+     LockInit(&m_threadSystemData.AllThreadsLock);
-+-
-++    m_threadSystemData.nrOfThreads = 0;
-+     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-+     LockInit(&m_threadSystemData.ReadyThreadsLock);
-+ }
-+@@ -642,6 +645,9 @@ ThreadGetId(
-+ 
-+     return (NULL != pThread) ? pThread->Id : 0;
-+ }
-++int getNrOfThreads() {
-++    return m_threadSystemData.nrOfThreads;
-++}
-+ 
-+ THREAD_PRIORITY
-+ ThreadGetPriority(
-+@@ -798,6 +804,7 @@ _ThreadInit(
-+ 
-+         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-+         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-++        m_threadSystemData.nrOfThreads++;
-+         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-+     }
-+     __finally
-+@@ -810,7 +817,7 @@ _ThreadInit(
-+                 pThread = NULL;
-+             }
-+         }
-+-
-++        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-+         *Thread = pThread;
-+ 
-+         LOG_FUNC_END;
-+@@ -1187,8 +1194,11 @@ _ThreadDestroy(
-+     ASSERT(NULL != pThread);
-+     ASSERT(NULL == Context);
-+ 
-++    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-++
-+     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-+     RemoveEntryList(&pThread->AllList);
-++    m_threadSystemData.nrOfThreads--;
-+     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
-+ 
-+     // This must be done before removing the thread from the process list, else
-diff --git a/src/Lab3.txt b/src/Lab3.txt
-new file mode 100644
-index 0000000..6ef5eee
---- /dev/null
-+++ b/src/Lab3.txt
-@@ -0,0 +1,182 @@
-+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-+index cec924b..ade0507 100644
-+--- a/postbuild/paths.cmd
-++++ b/postbuild/paths.cmd
-+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
-+ set PATH_TO_VM_TOOLS=__EMPTY__
-+ set VOL_MOUNT_LETTER=__EMPTY__
-+ 
-++if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
-+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
-+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
-+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-+@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
-+ 
-+ goto end
-+ 
-++:config_DESKTOP-6K9VMO8
-++
-++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-++SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-++SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-++SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-++SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-++goto end
-++
-+ :end
-+\ No newline at end of file
-+diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-+index be2588a..c5c6948 100644
-+--- a/src/HAL9000/headers/thread_internal.h
-++++ b/src/HAL9000/headers/thread_internal.h
-+@@ -282,3 +282,5 @@ void
-+ ThreadSetPriority(
-+     IN      THREAD_PRIORITY     NewPriority
-+     );
-++
-++int getNrOfThreads();
-+\ No newline at end of file
-+diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
-+index a7810ff..98b703d 100644
-+--- a/src/HAL9000/src/Entry64.c
-++++ b/src/HAL9000/src/Entry64.c
-+@@ -58,6 +58,8 @@ Entry64(
-+     DumpParameters(argv);
-+ 
-+     status = SystemInit(argv);
-++    LogSetLevel(LogLevelTrace);
-++    LogSetTracedComponents(LogComponentThread);
-+     ASSERT(SUCCEEDED(status));
-+ 
-+     LOGL("InitSystem executed successfully\n");
-+diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-+index f794c95..d85c26c 100644
-+--- a/src/HAL9000/src/cmd_thread_helper.c
-++++ b/src/HAL9000/src/cmd_thread_helper.c
-+@@ -128,7 +128,7 @@ void
-+     STATUS status;
-+ 
-+     ASSERT(NumberOfParameters == 0);
-+-
-++    LOG("Nr of Threads: %d", getNrOfThreads());
-+     LOG("%7s", "TID|");
-+     LOG("%20s", "Name|");
-+     LOG("%5s", "Prio|");
-+diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-+index b0b436e..efc7155 100644
-+--- a/src/HAL9000/src/system.c
-++++ b/src/HAL9000/src/system.c
-+@@ -70,7 +70,7 @@ SystemInit(
-+     status = STATUS_SUCCESS;
-+     pCpu = NULL;
-+ 
-+-    LogSystemInit(LogLevelInfo,
-++    LogSystemInit(LogLevelError,
-+                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-+                   TRUE
-+                   );
-+@@ -247,6 +247,7 @@ SystemInit(
-+     LOGL("Successfully intiialized system process!\n");
-+ 
-+     status = ThreadSystemInitIdleForCurrentCPU();
-++    LogSetLevel(LogLevelInfo);
-+     if (!SUCCEEDED(status))
-+     {
-+         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-+index b311f0c..0e9a004 100644
-+--- a/src/HAL9000/src/thread.c
-++++ b/src/HAL9000/src/thread.c
-+@@ -10,7 +10,7 @@
-+ #include "gdtmu.h"
-+ #include "pe_exports.h"
-+ 
-+-#define TID_INCREMENT               4
-++#define TID_INCREMENT               10
-+ 
-+ #define THREAD_TIME_SLICE           1
-+ 
-+@@ -32,6 +32,8 @@ typedef struct _THREAD_SYSTEM_DATA
-+     _Guarded_by_(AllThreadsLock)
-+     LIST_ENTRY          AllThreadsList;
-+ 
-++    int                 nrOfThreads;
-++
-+     LOCK                ReadyThreadsLock;
-+ 
-+     _Guarded_by_(ReadyThreadsLock)
-+@@ -121,6 +123,7 @@ _ThreadDereference(
-+     INOUT   PTHREAD                 Thread
-+     );
-+ 
-++
-+ static FUNC_FreeFunction            _ThreadDestroy;
-+ 
-+ static
-+@@ -142,7 +145,7 @@ ThreadSystemPreinit(
-+ 
-+     InitializeListHead(&m_threadSystemData.AllThreadsList);
-+     LockInit(&m_threadSystemData.AllThreadsLock);
-+-
-++    m_threadSystemData.nrOfThreads = 0;
-+     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-+     LockInit(&m_threadSystemData.ReadyThreadsLock);
-+ }
-+@@ -169,7 +172,8 @@ ThreadSystemInitMainForCurrentCPU(
-+ 
-+     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
-+ 
-+-    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-++    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-++    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
-+     if (!SUCCEEDED(status))
-+     {
-+         LOG_FUNC_ERROR("_ThreadInit", status );
-+@@ -642,6 +646,9 @@ ThreadGetId(
-+ 
-+     return (NULL != pThread) ? pThread->Id : 0;
-+ }
-++int getNrOfThreads() {
-++    return m_threadSystemData.nrOfThreads;
-++}
-+ 
-+ THREAD_PRIORITY
-+ ThreadGetPriority(
-+@@ -729,7 +736,7 @@ _ThreadInit(
-+     LOG_FUNC_START;
-+ 
-+     ASSERT(NULL != Name);
-+-    ASSERT(NULL != Thread);
-++    //ASSERT(NULL != Thread);
-+     ASSERT_INFO(ThreadPriorityLowest <= Priority && Priority <= ThreadPriorityMaximum,
-+                 "Priority is 0x%x\n", Priority);
-+ 
-+@@ -798,6 +805,7 @@ _ThreadInit(
-+ 
-+         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-+         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-++        m_threadSystemData.nrOfThreads++;
-+         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-+     }
-+     __finally
-+@@ -810,7 +818,7 @@ _ThreadInit(
-+                 pThread = NULL;
-+             }
-+         }
-+-
-++        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-+         *Thread = pThread;
-+ 
-+         LOG_FUNC_END;
-+@@ -1187,8 +1195,11 @@ _ThreadDestroy(
-+     ASSERT(NULL != pThread);
-+     ASSERT(NULL == Context);
-+ 
-++    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-++
-+     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-+     RemoveEntryList(&pThread->AllList);
-++    m_threadSystemData.nrOfThreads--;
-+     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
-+ 
-+     // This must be done before removing the thread from the process list, else
-diff --git a/src/Lab4.txt b/src/Lab4.txt
-new file mode 100644
-index 0000000..dd3af44
---- /dev/null
-+++ b/src/Lab4.txt
-@@ -0,0 +1,206 @@
-+diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-+index cec924b..ade0507 100644
-+--- a/postbuild/paths.cmd
-++++ b/postbuild/paths.cmd
-+@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
-+ set PATH_TO_VM_TOOLS=__EMPTY__
-+ set VOL_MOUNT_LETTER=__EMPTY__
-+ 
-++if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
-+ if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
-+ if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
-+ if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-+@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
-+ 
-+ goto end
-+ 
-++:config_DESKTOP-6K9VMO8
-++
-++SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-++SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-++SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-++SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-++SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-++goto end
-++
-+ :end
-+\ No newline at end of file
-+diff --git a/src/HAL9000/HAL9000.vcxproj b/src/HAL9000/HAL9000.vcxproj
-+index 0dd1641..d8104a5 100644
-+--- a/src/HAL9000/HAL9000.vcxproj
-++++ b/src/HAL9000/HAL9000.vcxproj
-+@@ -366,6 +366,7 @@
-+     <ClInclude Include="headers\um_application.h" />
-+     <ClInclude Include="headers\vmm.h" />
-+     <ClInclude Include="headers\vm_reservation_space.h" />
-++    <ClInclude Include="semaphore.h" />
-+   </ItemGroup>
-+   <ItemGroup>
-+     <YASM Include="src\_mboot32.yasm">
-+diff --git a/src/HAL9000/HAL9000.vcxproj.filters b/src/HAL9000/HAL9000.vcxproj.filters
-+index f31d483..2275548 100644
-+--- a/src/HAL9000/HAL9000.vcxproj.filters
-++++ b/src/HAL9000/HAL9000.vcxproj.filters
-+@@ -704,6 +704,9 @@
-+     <ClInclude Include="headers\test_process.h">
-+       <Filter>Header Files\debug\test\userprog</Filter>
-+     </ClInclude>
-++    <ClInclude Include="semaphore.h">
-++      <Filter>Header Files\executive</Filter>
-++    </ClInclude>
-+   </ItemGroup>
-+   <ItemGroup>
-+     <None Include="src\defines.yasm">
-+diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-+index be2588a..c5c6948 100644
-+--- a/src/HAL9000/headers/thread_internal.h
-++++ b/src/HAL9000/headers/thread_internal.h
-+@@ -282,3 +282,5 @@ void
-+ ThreadSetPriority(
-+     IN      THREAD_PRIORITY     NewPriority
-+     );
-++
-++int getNrOfThreads();
-+\ No newline at end of file
-+diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
-+index a7810ff..750f290 100644
-+--- a/src/HAL9000/src/Entry64.c
-++++ b/src/HAL9000/src/Entry64.c
-+@@ -58,6 +58,8 @@ Entry64(
-+     DumpParameters(argv);
-+ 
-+     status = SystemInit(argv);
-++    //LogSetLevel(LogLevelTrace);
-++    //LogSetTracedComponents(LogComponentThread);
-+     ASSERT(SUCCEEDED(status));
-+ 
-+     LOGL("InitSystem executed successfully\n");
-+diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-+index f794c95..d85c26c 100644
-+--- a/src/HAL9000/src/cmd_thread_helper.c
-++++ b/src/HAL9000/src/cmd_thread_helper.c
-+@@ -128,7 +128,7 @@ void
-+     STATUS status;
-+ 
-+     ASSERT(NumberOfParameters == 0);
-+-
-++    LOG("Nr of Threads: %d", getNrOfThreads());
-+     LOG("%7s", "TID|");
-+     LOG("%20s", "Name|");
-+     LOG("%5s", "Prio|");
-+diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-+index b0b436e..efc7155 100644
-+--- a/src/HAL9000/src/system.c
-++++ b/src/HAL9000/src/system.c
-+@@ -70,7 +70,7 @@ SystemInit(
-+     status = STATUS_SUCCESS;
-+     pCpu = NULL;
-+ 
-+-    LogSystemInit(LogLevelInfo,
-++    LogSystemInit(LogLevelError,
-+                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-+                   TRUE
-+                   );
-+@@ -247,6 +247,7 @@ SystemInit(
-+     LOGL("Successfully intiialized system process!\n");
-+ 
-+     status = ThreadSystemInitIdleForCurrentCPU();
-++    LogSetLevel(LogLevelInfo);
-+     if (!SUCCEEDED(status))
-+     {
-+         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-+diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-+index b311f0c..46ebf9c 100644
-+--- a/src/HAL9000/src/thread.c
-++++ b/src/HAL9000/src/thread.c
-+@@ -10,7 +10,7 @@
-+ #include "gdtmu.h"
-+ #include "pe_exports.h"
-+ 
-+-#define TID_INCREMENT               4
-++#define TID_INCREMENT               10
-+ 
-+ #define THREAD_TIME_SLICE           1
-+ 
-+@@ -32,10 +32,17 @@ typedef struct _THREAD_SYSTEM_DATA
-+     _Guarded_by_(AllThreadsLock)
-+     LIST_ENTRY          AllThreadsList;
-+ 
-++    int                 nrOfThreads;
-++
-+     LOCK                ReadyThreadsLock;
-+ 
-+     _Guarded_by_(ReadyThreadsLock)
-+     LIST_ENTRY          ReadyThreadsList;
-++
-++    //added for Threads projects
-++    _Guarded_by_(ReadyThreadsLock)
-++    THREAD_PRIORITY     RunningThreadsMinPriority;
-++
-+ } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
-+ 
-+ static THREAD_SYSTEM_DATA m_threadSystemData;
-+@@ -121,6 +128,7 @@ _ThreadDereference(
-+     INOUT   PTHREAD                 Thread
-+     );
-+ 
-++
-+ static FUNC_FreeFunction            _ThreadDestroy;
-+ 
-+ static
-+@@ -142,7 +150,7 @@ ThreadSystemPreinit(
-+ 
-+     InitializeListHead(&m_threadSystemData.AllThreadsList);
-+     LockInit(&m_threadSystemData.AllThreadsLock);
-+-
-++    m_threadSystemData.nrOfThreads = 0;
-+     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-+     LockInit(&m_threadSystemData.ReadyThreadsLock);
-+ }
-+@@ -170,6 +178,7 @@ ThreadSystemInitMainForCurrentCPU(
-+     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
-+ 
-+     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-++    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
-+     if (!SUCCEEDED(status))
-+     {
-+         LOG_FUNC_ERROR("_ThreadInit", status );
-+@@ -642,6 +651,9 @@ ThreadGetId(
-+ 
-+     return (NULL != pThread) ? pThread->Id : 0;
-+ }
-++int getNrOfThreads() {
-++    return m_threadSystemData.nrOfThreads;
-++}
-+ 
-+ THREAD_PRIORITY
-+ ThreadGetPriority(
-+@@ -798,6 +810,7 @@ _ThreadInit(
-+ 
-+         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-+         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-++        m_threadSystemData.nrOfThreads++;
-+         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-+     }
-+     __finally
-+@@ -810,7 +823,7 @@ _ThreadInit(
-+                 pThread = NULL;
-+             }
-+         }
-+-
-++        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-+         *Thread = pThread;
-+ 
-+         LOG_FUNC_END;
-+@@ -1187,8 +1200,11 @@ _ThreadDestroy(
-+     ASSERT(NULL != pThread);
-+     ASSERT(NULL == Context);
-+ 
-++    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-++
-+     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-+     RemoveEntryList(&pThread->AllList);
-++    m_threadSystemData.nrOfThreads--;
-+     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
-+ 
-+     // This must be done before removing the thread from the process list, else
-diff --git a/src/Lab4_1.txt b/src/Lab4_1.txt
-new file mode 100644
-index 0000000..e69de29
diff --git a/Lab5_2.txt b/Lab5_2.txt
deleted file mode 100644
index a4f03a0..0000000
--- a/Lab5_2.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-diff --git a/src/HAL9000/src/mutex.c b/src/HAL9000/src/mutex.c
-index 57db7e8..7b0bb58 100644
---- a/src/HAL9000/src/mutex.c
-+++ b/src/HAL9000/src/mutex.c
-@@ -105,6 +105,7 @@ MutexRelease(
-     else
-     {
-         Mutex->Holder = NULL;
-+        //here is the comment
-     }
- 
-     _Analysis_assume_lock_released_(*Mutex);
diff --git a/lab6.txt b/lab6.txt
deleted file mode 100644
index 03d5237..0000000
--- a/lab6.txt
+++ /dev/null
@@ -1,89 +0,0 @@
-diff --git a/PXE/Tests.module b/PXE/Tests.module
-index 3ad016f..e69de29 100644
---- a/PXE/Tests.module
-+++ b/PXE/Tests.module
-@@ -1,25 +0,0 @@
--/log ON
--/loglevel 0
--/logcomp 8000
--/run testthreadprioritydonationchain 16
--/run testthreadprioritydonationlower 16
--/run testthreadprioritydonationmulti 16
--/run testthreadprioritydonationmultiinverted 16
--/run testthreadprioritydonationmultithreads 16
--/run testthreadprioritydonationmultithreadsinverted 16
--/run testthreadprioritydonationnest 16
--/run testthreadprioritydonationonce 16
--/run testthreadprioritymutex 16
--/run testthreadpriorityroundrobin 16
--/run testthreadprioritywakeup 16
--/run testthreadpriorityyield 16
--/run testthreadtimerabsolute 16
--/run testthreadtimerabsolutepassed 16
--/run testthreadtimermultiplethreads 16
--/run testthreadtimermultipletimers 16
--/run testthreadtimerperiodicmultiple 16
--/run testthreadtimerperiodiconce 16
--/run testthreadtimerperiodiczero 16
--/run testthreadtimerrelative 16
--/run testthreadtimerrelativezero 16
--/shutdown
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index f9ab6d2..3ce3d8f 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -72,12 +72,13 @@ goto end
- 
- :config_DESKTOP-6K9VMO8
- 
--SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
--SET VOL_MOUNT_LETTER="Q:"
-+SET PATH_TO_LOG_FILE="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PXE_PATH="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\PXE"
-+SET PATH_TO_VM_FILE="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET PATH_TO_VM_DISK="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
- SET PATH_TO_VIX_TOOLS="D:\VMware"
--SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
--SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
--SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET VOL_MOUNT_LETTER="Q:"
- goto end
- 
- :end
-\ No newline at end of file
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index 20817b6..780a0bc 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -72,10 +72,15 @@ SystemInit(
-     status = STATUS_SUCCESS;
-     pCpu = NULL;
- 
--    LogSystemInit(LogLevelError,
-+    /*LogSystemInit(LogLevelError,
-                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                   TRUE
-                   );
-+                  */
-+    LogSystemInit(LogLevelTrace,
-+        LogComponentUserMode,
-+        TRUE
-+    );
- 
-     // if validation fails => the system will HALT
-     CpuMuValidateConfiguration();
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index 242f3be..63400e4 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -989,7 +989,8 @@ _ThreadSetupMainThreadUserStack(
-     ASSERT(ResultingStack != NULL);
-     ASSERT(Process != NULL);
- 
--    *ResultingStack = InitialStack;
-+    //*ResultingStack = InitialStack;
-+    *ResultingStack = (PVOID)PtrDiff(InitialStack, SHADOW_STACK_SIZE + sizeof(PVOID));
- 
-     return STATUS_SUCCESS;
- }
diff --git a/lab9.txt b/lab9.txt
new file mode 100644
index 0000000..8326c94
--- /dev/null
+++ b/lab9.txt
@@ -0,0 +1,372 @@
+diff --git a/lab7.txt b/lab7.txt
+deleted file mode 100644
+index c5222f6..0000000
+--- a/lab7.txt
++++ /dev/null
+@@ -1,137 +0,0 @@
+-diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
+-index 0cccd74..4ccbbeb 100644
+---- a/src/HAL9000/src/isr.c
+-+++ b/src/HAL9000/src/isr.c
+-@@ -143,6 +143,16 @@ _IsrExceptionHandler(
+-         LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
+-     }
+- 
+-+    if (!exceptionHandled)
+-+    {
+-+        if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
+-+        {
+-+            PPROCESS currProcess = GetCurrentProcess();
+-+            LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
+-+            ProcessTerminate(currProcess);
+-+        }
+-+    }
+-+
+-     // no use in logging if we solved the problem
+-     if (!exceptionHandled)
+-     {
+-diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
+-index 1576f7f..0464491 100644
+---- a/src/HAL9000/src/syscall.c
+-+++ b/src/HAL9000/src/syscall.c
+-@@ -7,6 +7,8 @@
+- #include "mmu.h"
+- #include "process_internal.h"
+- #include "dmp_cpu.h"
+-+#include "thread.h"
+-+#include "thread_internal.h"
+- 
+- extern void SyscallEntry();
+- 
+-@@ -68,6 +70,20 @@ SyscallHandler(
+-             status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
+-             break;
+-         // STUDENT TODO: implement the rest of the syscalls
+-+        case SyscallIdProcessExit:
+-+            status = SyscallProcessExit((STATUS)*pSyscallParameters);
+-+            break;
+-+        case SyscallIdThreadExit:
+-+            status = SyscallThreadExit((STATUS)*pSyscallParameters);
+-+            break;
+-+        case SyscallIdFileWrite:
+-+            status = SyscallFileWrite(
+-+                (UM_HANDLE)pSyscallParameters[0],
+-+                (PVOID)pSyscallParameters[1],
+-+                (QWORD)pSyscallParameters[2],
+-+                (QWORD*)pSyscallParameters[3]
+-+                );
+-+            break;
+-         default:
+-             LOG_ERROR("Unimplemented syscall called from User-space!\n");
+-             status = STATUS_UNSUPPORTED;
+-@@ -169,4 +185,47 @@ SyscallValidateInterface(
+-     return STATUS_SUCCESS;
+- }
+- 
+--// STUDENT TODO: implement the rest of the syscalls
+-\ No newline at end of file
+-+// STUDENT TODO: implement the rest of the syscalls
+-+STATUS
+-+SyscallFileWrite(
+-+    IN  UM_HANDLE                   FileHandle,
+-+    IN_READS_BYTES(BytesToWrite)
+-+     PVOID                       Buffer,
+-+    IN  QWORD                       BytesToWrite,
+-+    OUT QWORD * BytesWritten
+-+)
+-+{
+-+    if (BytesWritten == NULL) {
+-+        return STATUS_UNSUCCESSFUL;
+-+        
+-+    }
+-+    
+-+    if (FileHandle == UM_FILE_HANDLE_STDOUT) {
+-+        *BytesWritten = BytesToWrite;
+-+        LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
+-+        return STATUS_SUCCESS;
+-+    }
+-+    *BytesWritten = BytesToWrite;
+-+    return STATUS_SUCCESS;
+-+}
+-+
+-+STATUS
+-+SyscallThreadExit(
+-+    IN  STATUS                      ExitStatus
+-+)
+-+{
+-+    ThreadExit(ExitStatus);
+-+    return STATUS_SUCCESS;
+-+}
+-+
+-+STATUS
+-+SyscallProcessExit(
+-+    IN      STATUS                  ExitStatus
+-+)
+-+{
+-+    PPROCESS Process;
+-+    Process = GetCurrentProcess();
+-+    Process->TerminationStatus = ExitStatus;
+-+    ProcessTerminate(Process);
+-+    return STATUS_SUCCESS;
+-+}
+-\ No newline at end of file
+-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
+-index 780a0bc..9e03560 100644
+---- a/src/HAL9000/src/system.c
+-+++ b/src/HAL9000/src/system.c
+-@@ -77,8 +77,8 @@ SystemInit(
+-                   TRUE
+-                   );
+-                   */
+--    LogSystemInit(LogLevelTrace,
+--        LogComponentUserMode,
+-+    LogSystemInit(LogLevelInfo,
+-+        LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode | LogComponentMmu,
+-         TRUE
+-     );
+- 
+-diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
+-index a70a2cb..d5b5860 100644
+---- a/src/HAL9000/src/vmm.c
+-+++ b/src/HAL9000/src/vmm.c
+-@@ -269,7 +269,10 @@ VmmMapMemoryInternal(
+-     ctx.Uncacheable = Uncacheable;
+- 
+-     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
+--
+-+    if (!_VmIsKernelAddress(BaseAddress)) {
+-+        LOG("Will map virtual address 0x%X to physical address 0x%X\n",
+-+            BaseAddress, PhysicalAddress);
+-+    }
+-     _VmWalkPagingTables(cr3,
+-                         BaseAddress,
+-                         Size,
+diff --git a/src/HAL9000/headers.rar b/src/HAL9000/headers.rar
+new file mode 100644
+index 0000000..0592108
+Binary files /dev/null and b/src/HAL9000/headers.rar differ
+diff --git a/src/HAL9000/src.rar b/src/HAL9000/src.rar
+new file mode 100644
+index 0000000..8a9939c
+Binary files /dev/null and b/src/HAL9000/src.rar differ
+diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
+index d0b254f..fa5a0ee 100644
+--- a/src/HAL9000/src/cmd_interpreter.c
++++ b/src/HAL9000/src/cmd_interpreter.c
+@@ -13,6 +13,9 @@
+ #include "cmd_net_helper.h"
+ #include "cmd_basic.h"
+ #include "boot_module.h"
++#include "iomu.h"
++#include "process_internal.h"
++
+ 
+ #pragma warning(push)
+ 
+@@ -203,6 +206,25 @@ CmdRun(
+     DWORD bytesRead;
+ 
+     bytesRead = 0;
++    
++    for (DWORD i = 0; i < 16; ++i)
++    {
++        STATUS status;
++        PPROCESS pProcess;
++        char fullPath[MAX_PATH];
++
++        pProcess = NULL;
++
++        status = snprintf(fullPath, MAX_PATH, "%sAPPLIC~1\\VirtualAllocNormal.exe",
++            IomuGetSystemPartitionPath());
++        ASSERT(SUCCEEDED(status));
++
++        status = ProcessCreate(fullPath, NULL, &pProcess);
++        ASSERT(SUCCEEDED(status));
++    }
++    
++    
++    
+ 
+     exit = _CmdExecuteModuleCommands();
+     while (!exit)
+diff --git a/src/HAL9000/src/pmm.c b/src/HAL9000/src/pmm.c
+index 2347074..a064cb4 100644
+--- a/src/HAL9000/src/pmm.c
++++ b/src/HAL9000/src/pmm.c
+@@ -3,6 +3,8 @@
+ #include "int15.h"
+ #include "bitmap.h"
+ #include "synch.h"
++#include"thread_internal.h"
++#include "process.h"
+ 
+ typedef struct _MEMORY_REGION_LIST
+ {
+@@ -180,6 +182,21 @@ PmmReserveMemoryEx(
+ 
+     LockRelease( &m_pmmData.AllocationLock, oldState);
+ 
++    PTHREAD pThread = GetCurrentThread();
++    PPROCESS pCurrentProcess = NULL;
++    BOOLEAN bSystemProcess;
++
++    if (pThread != NULL)
++    {
++        pCurrentProcess = pThread->Process;
++    }
++
++    bSystemProcess = (pCurrentProcess == NULL) || ProcessIsSystem(pCurrentProcess);
++
++    LOG("Reserved physical frames from 0x%X of size 0x%X on behalf of [%s] process\n",
++        idx * PAGE_SIZE, ((QWORD)NoOfFrames * PAGE_SIZE),
++        bSystemProcess ? "SYSTEM" : ProcessGetName(pCurrentProcess));
++
+     return (PHYSICAL_ADDRESS) ( (QWORD) idx * PAGE_SIZE );
+ }
+ 
+diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
+index a625f9d..dd42248 100644
+--- a/src/HAL9000/src/syscall.c
++++ b/src/HAL9000/src/syscall.c
+@@ -9,6 +9,7 @@
+ #include "dmp_cpu.h"
+ #include "thread.h"
+ #include "thread_internal.h"
++#include "vmm.h"
+ 
+ extern void SyscallEntry();
+ 
+@@ -84,30 +85,16 @@ SyscallHandler(
+                 (QWORD*)pSyscallParameters[3]
+                 );
+             break;
+-        case SyscallIdThreadCreate:
+-            status = SyscallThreadCreate(
+-                (PFUNC_ThreadStart)pSyscallParameters[0],
+-                (PVOID)pSyscallParameters[1],
+-                (UM_HANDLE*)pSyscallParameters[2]);
+-            break;
+-        case SyscallIdThreadGetTid:
+-            status = SyscallThreadGetTid(
+-                (UM_HANDLE)pSyscallParameters[0],
+-                (TID*)pSyscallParameters[1]);
+-            break;
+-        case SyscallIdProcessGetPid:
+-            status = SyscallProcessGetPid(
+-                (UM_HANDLE)pSyscallParameters[0],
+-                (PID*)pSyscallParameters[1]);
+-            break;
+-        case SyscallIdThreadWaitForTermination :
+-            status = SyscallThreadWaitForTermination(
+-                (UM_HANDLE)pSyscallParameters[0],
+-                (STATUS*)pSyscallParameters[1]);
+-            break;
+-        case SyscallIdThreadCloseHandle :
+-            status = SyscallThreadCloseHandle(
+-                (UM_HANDLE)pSyscallParameters[0]);
++        case SyscallIdVirtualAlloc:
++            status = SyscallVirtualAlloc(
++                (PVOID)pSyscallParameters[0],
++                (QWORD)pSyscallParameters[1],
++                (VMM_ALLOC_TYPE)pSyscallParameters[2],
++                (PAGE_RIGHTS)pSyscallParameters[3],
++                (UM_HANDLE)pSyscallParameters[4],
++                (QWORD)pSyscallParameters[5],
++                (PVOID)pSyscallParameters[6]
++            );
+             break;
+ 
+         default:
+@@ -244,55 +231,6 @@ SyscallThreadExit(
+     return STATUS_SUCCESS;
+ }
+ 
+-STATUS
+-SyscallThreadCreate(
+-    IN      PFUNC_ThreadStart       StartFunction,
+-    IN_OPT  PVOID                   Context,
+-    OUT     UM_HANDLE* ThreadHandle
+-) {
+-    PTHREAD thread = NULL;
+-    if (StartFunction == NULL) {
+-        return STATUS_UNSUCCESSFUL;
+-    }
+-    ThreadCreate("name", ThreadPriorityDefault, StartFunction, Context, &thread);
+-    ThreadHandle = (UM_HANDLE*)thread;
+-    return STATUS_SUCCESS;
+-}
+-STATUS
+-SyscallThreadGetTid(
+-    IN_OPT  UM_HANDLE               ThreadHandle,
+-    OUT     TID* ThreadId
+-) {
+-    *ThreadId = ThreadGetId((PTHREAD)ThreadHandle);
+-    return STATUS_SUCCESS;
+-}
+-STATUS
+-SyscallThreadWaitForTermination(
+-    IN      UM_HANDLE               ThreadHandle,
+-    OUT     STATUS* TerminationStatus
+-) {
+-    ThreadWaitForTermination((PTHREAD)ThreadHandle,&TerminationStatus);
+-    return STATUS_SUCCESS;
+-}
+-
+-STATUS
+-SyscallThreadCloseHandle(
+-    IN      UM_HANDLE               ThreadHandle
+-) {
+-    ThreadCloseHandle((PTHREAD)ThreadHandle);
+-    return STATUS_SUCCESS;
+-}
+-
+-
+-STATUS
+-SyscallProcessGetPid(
+-    IN_OPT  UM_HANDLE               ProcessHandle,
+-    OUT     PID* ProcessId
+-) {
+-    *ProcessId = ProcessGetId((PPROCESS)ProcessHandle);
+-    return STATUS_SUCCESS;
+-}
+-
+ STATUS
+ SyscallProcessExit(
+     IN      STATUS                  ExitStatus
+@@ -303,4 +241,22 @@ SyscallProcessExit(
+     Process->TerminationStatus = ExitStatus;
+     ProcessTerminate(Process);
+     return STATUS_SUCCESS;
++}
++
++STATUS
++SyscallVirtualAlloc(
++    IN_OPT      PVOID                   BaseAddress,
++    IN          QWORD                   Size,
++    IN          VMM_ALLOC_TYPE          AllocType,
++    IN          PAGE_RIGHTS             PageRights,
++    IN_OPT      UM_HANDLE               FileHandle,
++    IN_OPT      QWORD                   Key,
++    OUT         PVOID* AllocatedAddress
++)
++{
++    UNREFERENCED_PARAMETER(Key);
++    UNREFERENCED_PARAMETER(FileHandle)
++    PVOID address = VmmAllocRegionEx(BaseAddress,Size,AllocType,PageRights,FALSE,NULL,NULL,NULL,NULL);
++    *AllocatedAddress = address;
++    return STATUS_SUCCESS;
+ }
+\ No newline at end of file
+diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
+index d5b5860..f3d9df2 100644
+--- a/src/HAL9000/src/vmm.c
++++ b/src/HAL9000/src/vmm.c
+@@ -571,6 +571,8 @@ VmmAllocRegionEx(
+             LOG_FUNC_ERROR("VmReservationSpaceAllocRegion", status);
+             __leave;
+         }
++        LOG("Allocating for VaSpace at 0x%X, a memory region from 0x%X of size 0x%X\n",
++            pVaSpace, pBaseAddress, alignedSize);
+         ASSERT(NULL != pBaseAddress);
+ 
+         if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY))
diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
index 3ce3d8f..de51fb1 100644
--- a/postbuild/paths.cmd
+++ b/postbuild/paths.cmd
@@ -73,12 +73,12 @@ goto end
 :config_DESKTOP-6K9VMO8
 
 SET PATH_TO_LOG_FILE="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
+SET PATH_TO_VIX_TOOLS="D:\VMware"
+SET VOL_MOUNT_LETTER="Q:"
 SET PXE_PATH="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\PXE"
-SET PATH_TO_VM_FILE="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
 SET PATH_TO_VM_DISK="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
 SET PATH_TO_VM_TOOLS="C:\Program Files (x86)\VMware\VMware Virtual Disk Development Kit"
-SET PATH_TO_VIX_TOOLS="D:\VMware"
-SET VOL_MOUNT_LETTER="Q:"
+SET PATH_TO_VM_FILE="D:\faculta\OSD_HAL\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
 goto end
 
 :end
\ No newline at end of file
diff --git a/src/.gitignore b/src/.gitignore
deleted file mode 100644
index a4d6d9c..0000000
--- a/src/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-.vs/
\ No newline at end of file
diff --git a/src/HAL9000/HAL9000.vcxproj b/src/HAL9000/HAL9000.vcxproj
index f614446..0dd1641 100644
--- a/src/HAL9000/HAL9000.vcxproj
+++ b/src/HAL9000/HAL9000.vcxproj
@@ -181,7 +181,6 @@
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
-    <ClCompile Include="semaphore.c" />
     <ClCompile Include="src\acpi_interface.c" />
     <ClCompile Include="src\acpi_osl.c" />
     <ClCompile Include="src\ap_tramp.c" />
@@ -367,7 +366,6 @@
     <ClInclude Include="headers\um_application.h" />
     <ClInclude Include="headers\vmm.h" />
     <ClInclude Include="headers\vm_reservation_space.h" />
-    <ClInclude Include="semaphore.h" />
   </ItemGroup>
   <ItemGroup>
     <YASM Include="src\_mboot32.yasm">
diff --git a/src/HAL9000/HAL9000.vcxproj.filters b/src/HAL9000/HAL9000.vcxproj.filters
index 6797bc4..f31d483 100644
--- a/src/HAL9000/HAL9000.vcxproj.filters
+++ b/src/HAL9000/HAL9000.vcxproj.filters
@@ -402,9 +402,6 @@
     <ClCompile Include="src\test_process.c">
       <Filter>Source Files\debug\test\userprog</Filter>
     </ClCompile>
-    <ClCompile Include="semaphore.c">
-      <Filter>Source Files\executive</Filter>
-    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="headers\HAL9000.h">
@@ -707,9 +704,6 @@
     <ClInclude Include="headers\test_process.h">
       <Filter>Header Files\debug\test\userprog</Filter>
     </ClInclude>
-    <ClInclude Include="semaphore.h">
-      <Filter>Header Files\executive</Filter>
-    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <None Include="src\defines.yasm">
diff --git a/src/HAL9000/headers.rar b/src/HAL9000/headers.rar
deleted file mode 100644
index 0592108..0000000
Binary files a/src/HAL9000/headers.rar and /dev/null differ
diff --git a/src/HAL9000/headers/ex_timer.h b/src/HAL9000/headers/ex_timer.h
index 3b49820..9339ccc 100644
--- a/src/HAL9000/headers/ex_timer.h
+++ b/src/HAL9000/headers/ex_timer.h
@@ -1,7 +1,4 @@
 #pragma once
-#include "lock_common.h"
-#include "list.h"
-#include "ex_event.h"
 
 typedef enum _EX_TIMER_TYPE
 {
@@ -23,10 +20,7 @@ typedef struct _EX_TIMER
 
     volatile BOOLEAN    TimerStarted;
     BOOLEAN             TimerUninited;
-
-    EX_EVENT            TimerEvent;
-    LIST_ENTRY          TimerListEvent;
-} EX_TIMER, * PEX_TIMER;
+} EX_TIMER, *PEX_TIMER;
 
 //******************************************************************************
 // Function:     ExTimerInit
@@ -50,22 +44,13 @@ typedef struct _EX_TIMER
 //
 // Initialize an absolute timer after the OS has run 2 minutes:
 // ExTimerInit(&timer, ExTimerTypeAbsolute, 120 * SEC_IN_US);
-
-
-struct _GLOBAL_TIMER_LIST
-{
-    LOCK            TimerListLock;
-    LIST_ENTRY      TimerListHead;
-};
-
-static struct _GLOBAL_TIMER_LIST m_globalTimerList;
-
+//******************************************************************************
 STATUS
 ExTimerInit(
     OUT     PEX_TIMER       Timer,
     IN      EX_TIMER_TYPE   Type,
     IN      QWORD           TimeUs
-);
+    );
 
 //******************************************************************************
 // Function:     ExTimerStart
@@ -77,7 +62,7 @@ ExTimerInit(
 void
 ExTimerStart(
     IN      PEX_TIMER       Timer
-);
+    );
 
 //******************************************************************************
 // Function:     ExTimerStop
@@ -89,7 +74,7 @@ ExTimerStart(
 void
 ExTimerStop(
     IN      PEX_TIMER       Timer
-);
+    );
 
 //******************************************************************************
 // Function:     ExTimerWait
@@ -102,7 +87,7 @@ ExTimerStop(
 void
 ExTimerWait(
     INOUT   PEX_TIMER       Timer
-);
+    );
 
 //******************************************************************************
 // Function:     ExTimerUninit
@@ -115,7 +100,7 @@ ExTimerWait(
 void
 ExTimerUninit(
     INOUT   PEX_TIMER       Timer
-);
+    );
 
 //******************************************************************************
 // Function:     ExTimerCompareTimers
@@ -130,27 +115,4 @@ INT64
 ExTimerCompareTimers(
     IN      PEX_TIMER     FirstElem,
     IN      PEX_TIMER     SecondElem
-);
-
-void
-ExTimerCheckAll(
-    void
-);
-
-STATUS
-ExTimerCheck(
-    IN PLIST_ENTRY Timer,
-    IN_OPT PVOID context
-);
-
-INT64
-ExTimerCompareListElems(
-    IN PLIST_ENTRY t1,
-    IN PLIST_ENTRY t2,
-    IN_OPT PVOID context
-);
-
-void
-ExTimerSystemPreinit(
-    void
-);
\ No newline at end of file
+    );
diff --git a/src/HAL9000/headers/process_internal.h b/src/HAL9000/headers/process_internal.h
index 7ebdcc6..dd19c20 100644
--- a/src/HAL9000/headers/process_internal.h
+++ b/src/HAL9000/headers/process_internal.h
@@ -58,6 +58,11 @@ typedef struct _PROCESS
 
     // VaSpace used only for UM virtual memory allocations
     struct _VMM_RESERVATION_SPACE*  VaSpace;
+
+    LOCK                            FrameMapLock;
+
+    _Guarded_by_(FrameMapLock)
+    LIST_ENTRY                      FrameMappingsHead;
 } PROCESS, *PPROCESS;
 
 //******************************************************************************
diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
index c5c6948..be2588a 100644
--- a/src/HAL9000/headers/thread_internal.h
+++ b/src/HAL9000/headers/thread_internal.h
@@ -282,5 +282,3 @@ void
 ThreadSetPriority(
     IN      THREAD_PRIORITY     NewPriority
     );
-
-int getNrOfThreads();
\ No newline at end of file
diff --git a/src/HAL9000/semaphore.c b/src/HAL9000/semaphore.c
deleted file mode 100644
index be8e67e..0000000
--- a/src/HAL9000/semaphore.c
+++ /dev/null
@@ -1,77 +0,0 @@
-#include "HAL9000.h"
-#include "thread_internal.h"
-#include "semaphore.h"
-
-void
-SemaphoreInit(
-    OUT     PSEMAPHORE      Semaphore,
-    IN      DWORD           InitialValue
-) {
-    ASSERT(NULL != Semaphore);
-
-    memzero(Semaphore, sizeof(SEMAPHORE));
-
-    LockInit(&Semaphore->SemaphoreLock);
-
-    InitializeListHead(&Semaphore->WaitingList);
-
-    Semaphore->Value = InitialValue;
-
-}
-
-void
-SemaphoreDown(
-    INOUT   PSEMAPHORE      Semaphore,
-    IN      DWORD           Value
-) {
-    INTR_STATE dummystate;
-    INTR_STATE oldState;
-    PTHREAD pCurrentThread = GetCurrentThread();
-
-    ASSERT(NULL != Semaphore);
-    ASSERT(NULL != pCurrentThread);
-
-    oldState = CpuIntrDisable();
-
-    LockAcquire(&Semaphore->SemaphoreLock, &dummystate);
-    
-    while (Semaphore->Value - Value < 0) {
-        InsertTailList(&Semaphore->WaitingList, &pCurrentThread->ReadyList);
-        ThreadTakeBlockLock();
-        LockRelease(&Semaphore->SemaphoreLock, dummystate);
-        ThreadBlock();
-        LockAcquire(&Semaphore->SemaphoreLock, &dummystate);
-    }
-    
-    Semaphore->Value = Semaphore->Value - Value;
-    LockRelease(&Semaphore->SemaphoreLock, dummystate);
-
-    CpuIntrSetState(oldState);
-    
-}
-
-void
-SemaphoreUp(
-    INOUT   PSEMAPHORE      Semaphore,
-    IN      DWORD           Value
-) {
-
-    INTR_STATE oldState;
-    PLIST_ENTRY pEntry = NULL;
-
-    ASSERT(NULL != Semaphore);
-
-    LockAcquire(&Semaphore->SemaphoreLock, &oldState);
-
-    Semaphore->Value += Value;
-
-    pEntry = RemoveHeadList(&Semaphore->WaitingList);
-    if (pEntry != &Semaphore->WaitingList)
-    {
-        PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
-        ThreadUnblock(pThread);
-    }
-
-    LockRelease(&Semaphore->SemaphoreLock, oldState);
-
-}
\ No newline at end of file
diff --git a/src/HAL9000/semaphore.h b/src/HAL9000/semaphore.h
deleted file mode 100644
index 047c096..0000000
--- a/src/HAL9000/semaphore.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#pragma once
-
-#include "list.h"
-#include "synch.h"
-#include "HAL9000.h"
-
-
-typedef struct _SEMAPHORE
-{
-    DWORD           Value;
-    LOCK            SemaphoreLock;
-
-    _Guarded_by_(SemaphoreLock)
-    LIST_ENTRY          WaitingList;
-    // ... add more fields here ...
-} SEMAPHORE, * PSEMAPHORE;
-
-void
-SemaphoreInit(
-    OUT     PSEMAPHORE      Semaphore,
-    IN      DWORD           InitialValue
-);
-
-void
-SemaphoreDown(
-    INOUT   PSEMAPHORE      Semaphore,
-    IN      DWORD           Value
-);
-
-void
-SemaphoreUp(
-    INOUT   PSEMAPHORE      Semaphore,
-    IN      DWORD           Value
-);
\ No newline at end of file
diff --git a/src/HAL9000/src.rar b/src/HAL9000/src.rar
deleted file mode 100644
index 8a9939c..0000000
Binary files a/src/HAL9000/src.rar and /dev/null differ
diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
index 750f290..a7810ff 100644
--- a/src/HAL9000/src/Entry64.c
+++ b/src/HAL9000/src/Entry64.c
@@ -58,8 +58,6 @@ Entry64(
     DumpParameters(argv);
 
     status = SystemInit(argv);
-    //LogSetLevel(LogLevelTrace);
-    //LogSetTracedComponents(LogComponentThread);
     ASSERT(SUCCEEDED(status));
 
     LOGL("InitSystem executed successfully\n");
diff --git a/src/HAL9000/src/cmd_interpreter.c b/src/HAL9000/src/cmd_interpreter.c
index fa5a0ee..d0b254f 100644
--- a/src/HAL9000/src/cmd_interpreter.c
+++ b/src/HAL9000/src/cmd_interpreter.c
@@ -13,9 +13,6 @@
 #include "cmd_net_helper.h"
 #include "cmd_basic.h"
 #include "boot_module.h"
-#include "iomu.h"
-#include "process_internal.h"
-
 
 #pragma warning(push)
 
@@ -206,25 +203,6 @@ CmdRun(
     DWORD bytesRead;
 
     bytesRead = 0;
-    
-    for (DWORD i = 0; i < 16; ++i)
-    {
-        STATUS status;
-        PPROCESS pProcess;
-        char fullPath[MAX_PATH];
-
-        pProcess = NULL;
-
-        status = snprintf(fullPath, MAX_PATH, "%sAPPLIC~1\\VirtualAllocNormal.exe",
-            IomuGetSystemPartitionPath());
-        ASSERT(SUCCEEDED(status));
-
-        status = ProcessCreate(fullPath, NULL, &pProcess);
-        ASSERT(SUCCEEDED(status));
-    }
-    
-    
-    
 
     exit = _CmdExecuteModuleCommands();
     while (!exit)
diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
index d85c26c..f794c95 100644
--- a/src/HAL9000/src/cmd_thread_helper.c
+++ b/src/HAL9000/src/cmd_thread_helper.c
@@ -128,7 +128,7 @@ void
     STATUS status;
 
     ASSERT(NumberOfParameters == 0);
-    LOG("Nr of Threads: %d", getNrOfThreads());
+
     LOG("%7s", "TID|");
     LOG("%20s", "Name|");
     LOG("%5s", "Prio|");
diff --git a/src/HAL9000/src/ex_event.c b/src/HAL9000/src/ex_event.c
index 162bbd1..c185e77 100644
--- a/src/HAL9000/src/ex_event.c
+++ b/src/HAL9000/src/ex_event.c
@@ -97,8 +97,7 @@ ExEventWaitForSignal(
     while (TRUE != _InterlockedCompareExchange8(&Event->Signaled, newState, TRUE))
     {
         LockAcquire(&Event->EventLock, &dummyState);
-        //InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
-        InsertOrderedList(&Event->WaitingList, &pCurrentThread->ReadyList, ThreadComparePriorityReadyList, NULL);
+        InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
         ThreadTakeBlockLock();
         LockRelease(&Event->EventLock, dummyState);
         ThreadBlock();
diff --git a/src/HAL9000/src/ex_system.c b/src/HAL9000/src/ex_system.c
index de7b384..bf91550 100644
--- a/src/HAL9000/src/ex_system.c
+++ b/src/HAL9000/src/ex_system.c
@@ -1,7 +1,6 @@
 #include "HAL9000.h"
 #include "ex_system.h"
 #include "thread_internal.h"
-#include "ex_timer.h"
 
 void
 ExSystemTimerTick(
@@ -9,5 +8,4 @@ ExSystemTimerTick(
     )
 {
     ThreadTick();
-    ExTimerCheckAll();
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/ex_timer.c b/src/HAL9000/src/ex_timer.c
index 236cfaf..65c769f 100644
--- a/src/HAL9000/src/ex_timer.c
+++ b/src/HAL9000/src/ex_timer.c
@@ -3,34 +3,12 @@
 #include "iomu.h"
 #include "thread_internal.h"
 
-
-INT64
-ExTimerCompareListElems(
-    IN PLIST_ENTRY t1,
-    IN PLIST_ENTRY t2,
-    IN_OPT PVOID context
-)
-{
-    ASSERT(NULL == context);
-    EX_TIMER* timer1 = CONTAINING_RECORD(t1, EX_TIMER, TimerListEvent);
-    EX_TIMER* timer2 = CONTAINING_RECORD(t2, EX_TIMER, TimerListEvent);
-
-    if (ExTimerCompareTimers(timer1, timer2) > 0) {
-        return 1;
-    }
-    if (ExTimerCompareTimers(timer1, timer2) == 0) {
-        return 0;
-    }
-
-    return -1;
-}
-
 STATUS
 ExTimerInit(
     OUT     PEX_TIMER       Timer,
     IN      EX_TIMER_TYPE   Type,
     IN      QWORD           Time
-)
+    )
 {
     STATUS status;
 
@@ -64,56 +42,13 @@ ExTimerInit(
         Timer->TriggerTimeUs = Time;
     }
 
-    INTR_STATE dummyState;
-
-    ExEventInit(&Timer->TimerEvent, ExEventTypeNotification, FALSE);
-    LockAcquire(&m_globalTimerList.TimerListLock, &dummyState);
-    InsertOrderedList(&m_globalTimerList.TimerListHead, &Timer->TimerListEvent, ExTimerCompareListElems, NULL);
-    LockRelease(&m_globalTimerList.TimerListLock, dummyState);
-
     return status;
 }
 
-void
-ExTimerSystemPreinit(
-    void
-)
-{
-    InitializeListHead(&m_globalTimerList.TimerListHead);
-    LockInit(&m_globalTimerList.TimerListLock);
-}
-
-STATUS
-ExTimerCheck(
-    IN PLIST_ENTRY Timer,
-    IN_OPT PVOID context
-)
-{
-
-    ASSERT(NULL == context);
-    QWORD system_time = IomuGetSystemTimeUs();
-    EX_TIMER* timer = CONTAINING_RECORD(Timer, EX_TIMER, TimerListEvent);
-    if (system_time >= timer->TriggerTimeUs) {
-        ExEventSignal(&timer->TimerEvent);
-    }
-    return STATUS_SUCCESS;
-}
-
-void
-ExTimerCheckAll(
-    void
-)
-{
-    INTR_STATE dummyState;
-    LockAcquire(&m_globalTimerList.TimerListLock, &dummyState);
-    ForEachElementExecute(&m_globalTimerList.TimerListHead, (PFUNC_ListFunction)ExTimerCheck, NULL, FALSE);
-    LockRelease(&m_globalTimerList.TimerListLock, dummyState);
-}
-
 void
 ExTimerStart(
     IN      PEX_TIMER       Timer
-)
+    )
 {
     ASSERT(Timer != NULL);
 
@@ -128,7 +63,7 @@ ExTimerStart(
 void
 ExTimerStop(
     IN      PEX_TIMER       Timer
-)
+    )
 {
     ASSERT(Timer != NULL);
 
@@ -138,13 +73,12 @@ ExTimerStop(
     }
 
     Timer->TimerStarted = FALSE;
-    ExEventSignal(&Timer->TimerEvent);
 }
 
 void
 ExTimerWait(
     INOUT   PEX_TIMER       Timer
-)
+    )
 {
     ASSERT(Timer != NULL);
 
@@ -153,28 +87,22 @@ ExTimerWait(
         return;
     }
 
-    /*while (IomuGetSystemTimeUs() < Timer->TriggerTimeUs && Timer->TimerStarted)
+    while (IomuGetSystemTimeUs() < Timer->TriggerTimeUs && Timer->TimerStarted)
     {
         ThreadYield();
-    }*/
-    ExEventWaitForSignal(&Timer->TimerEvent);
+    }
 }
 
 void
 ExTimerUninit(
     INOUT   PEX_TIMER       Timer
-)
+    )
 {
     ASSERT(Timer != NULL);
 
     ExTimerStop(Timer);
 
     Timer->TimerUninited = TRUE;
-
-    INTR_STATE dummyState;
-    LockAcquire(&m_globalTimerList.TimerListLock, &dummyState);
-    RemoveEntryList(&Timer->TimerListEvent);
-    LockRelease(&m_globalTimerList.TimerListLock, dummyState);
 }
 
 INT64
diff --git a/src/HAL9000/src/isr.c b/src/HAL9000/src/isr.c
index 4ccbbeb..168d5ec 100644
--- a/src/HAL9000/src/isr.c
+++ b/src/HAL9000/src/isr.c
@@ -12,22 +12,22 @@
 #define UNDEFINED_INTERRUPT_TEXT                "UNKNOWN INTERRUPT"
 #define STACK_BYTES_TO_DUMP_ON_EXCEPTION        0x100
 
-const char EXCEPTION_NAME[ExceptionVirtualizationException+1][MAX_PATH] = { "#DE - Divide Error", "#DB - Debug Exception", "NMI Interrupt",
-                                                                            "#BP - Breakpoint Exception", "#OF - Overflow Exception", "#BR - BOUND Range Exceeded Exception",
-                                                                            "#UD - Invalid Opcode Exception", "#NM - Device Not Available Exception", "#DF - Double Fault Exception",
-                                                                            "Coprocessor Segment Overrun", "#TS - Invalid TSS Exception", "#NP - Segment Not Present",
-                                                                            "#SS - Stack Fault Exception", "#GP - General Protection Exception", "#PF - Page-Fault Exception",
-                                                                            UNDEFINED_INTERRUPT_TEXT, "#MF - x87 FPU Floating-Point Error", "#AC - Alignment Check",
-                                                                            "#MC - Machine-Check Exception", "#XM - SIMD Floating-Point Exception", "#VE - Virtualization Exception"
-                                                                        };
-
-const char INTERRUPT_NAME[NO_OF_IRQS][MAX_PATH] = {     "Timer", "Keyboard", "Cascade",
-                                                        "COM2", "COM1", UNDEFINED_INTERRUPT_TEXT,
-                                                        "Diskette", "LPT1", "CMOS RTC",
-                                                        "CGA", UNDEFINED_INTERRUPT_TEXT,UNDEFINED_INTERRUPT_TEXT
-                                                        UNDEFINED_INTERRUPT_TEXT, "FPU","Hard Disk",UNDEFINED_INTERRUPT_TEXT,
-                                                        UNDEFINED_INTERRUPT_TEXT
-                                                        };
+const char EXCEPTION_NAME[ExceptionVirtualizationException + 1][MAX_PATH] = { "#DE - Divide Error", "#DB - Debug Exception", "NMI Interrupt",
+																			"#BP - Breakpoint Exception", "#OF - Overflow Exception", "#BR - BOUND Range Exceeded Exception",
+																			"#UD - Invalid Opcode Exception", "#NM - Device Not Available Exception", "#DF - Double Fault Exception",
+																			"Coprocessor Segment Overrun", "#TS - Invalid TSS Exception", "#NP - Segment Not Present",
+																			"#SS - Stack Fault Exception", "#GP - General Protection Exception", "#PF - Page-Fault Exception",
+																			UNDEFINED_INTERRUPT_TEXT, "#MF - x87 FPU Floating-Point Error", "#AC - Alignment Check",
+																			"#MC - Machine-Check Exception", "#XM - SIMD Floating-Point Exception", "#VE - Virtualization Exception"
+};
+
+const char INTERRUPT_NAME[NO_OF_IRQS][MAX_PATH] = { "Timer", "Keyboard", "Cascade",
+														"COM2", "COM1", UNDEFINED_INTERRUPT_TEXT,
+														"Diskette", "LPT1", "CMOS RTC",
+														"CGA", UNDEFINED_INTERRUPT_TEXT,UNDEFINED_INTERRUPT_TEXT
+														UNDEFINED_INTERRUPT_TEXT, "FPU","Hard Disk",UNDEFINED_INTERRUPT_TEXT,
+														UNDEFINED_INTERRUPT_TEXT
+};
 
 static PFUNC_IsrRoutine m_isrRoutines[NO_OF_USABLE_INTERRUPTS] = { NULL };
 static PVOID m_isrContexts[NO_OF_USABLE_INTERRUPTS] = { NULL };
@@ -35,236 +35,234 @@ static PVOID m_isrContexts[NO_OF_USABLE_INTERRUPTS] = { NULL };
 static
 void
 _IsrExceptionHandler(
-    IN BYTE                         InterruptIndex,
-    IN PINTERRUPT_STACK_COMPLETE    StackPointer,
-    IN BOOLEAN                      ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*    ProcessorState
-    );
+	IN BYTE                         InterruptIndex,
+	IN PINTERRUPT_STACK_COMPLETE    StackPointer,
+	IN BOOLEAN                      ErrorCodeAvailable,
+	IN COMPLETE_PROCESSOR_STATE* ProcessorState
+);
 
 static
 void
 _IsrInterruptHandler(
-    IN BYTE             InterruptIndex
-    );
+	IN BYTE             InterruptIndex
+);
 
 
 void
 IsrCommonHandler(
-    IN BYTE                                 InterruptIndex,
-    IN PINTERRUPT_STACK_COMPLETE            StackPointer,
-    IN BOOLEAN                              ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*            ProcessorState
-    )
+	IN BYTE                                 InterruptIndex,
+	IN PINTERRUPT_STACK_COMPLETE            StackPointer,
+	IN BOOLEAN                              ErrorCodeAvailable,
+	IN COMPLETE_PROCESSOR_STATE* ProcessorState
+)
 {
-    PPCPU pPcpu;
-
-    CHECK_STACK_ALIGNMENT;
-
-    ASSERT(CpuIntrGetState() == INTR_OFF);
-
-    pPcpu = GetCurrentPcpu();
-    if (NULL != pPcpu)
-    {
-        // in the early stages the PCPU may have not been yet set
-        pPcpu->InterruptsTriggered[InterruptIndex] += 1;
-    }
-
-    if (InterruptIndex < NO_OF_RESERVED_EXCEPTIONS)
-    {
-        _IsrExceptionHandler(InterruptIndex, StackPointer, ErrorCodeAvailable, ProcessorState);
-    }
-    else
-    {
-        _IsrInterruptHandler(InterruptIndex);
-    }
+	PPCPU pPcpu;
+
+	CHECK_STACK_ALIGNMENT;
+
+	ASSERT(CpuIntrGetState() == INTR_OFF);
+
+	pPcpu = GetCurrentPcpu();
+	if (NULL != pPcpu)
+	{
+		// in the early stages the PCPU may have not been yet set
+		pPcpu->InterruptsTriggered[InterruptIndex] += 1;
+	}
+
+	if (InterruptIndex < NO_OF_RESERVED_EXCEPTIONS)
+	{
+		_IsrExceptionHandler(InterruptIndex, StackPointer, ErrorCodeAvailable, ProcessorState);
+	}
+	else
+	{
+		_IsrInterruptHandler(InterruptIndex);
+	}
 }
 
 static
 void
 _IsrExceptionHandler(
-    IN BYTE                         InterruptIndex,
-    IN PINTERRUPT_STACK_COMPLETE    StackPointer,
-    IN BOOLEAN                      ErrorCodeAvailable,
-    IN COMPLETE_PROCESSOR_STATE*             ProcessorState
-    )
+	IN BYTE                         InterruptIndex,
+	IN PINTERRUPT_STACK_COMPLETE    StackPointer,
+	IN BOOLEAN                      ErrorCodeAvailable,
+	IN COMPLETE_PROCESSOR_STATE* ProcessorState
+)
 {
-    DWORD errorCode;
-    BOOLEAN exceptionHandled;
-
-    errorCode = 0;
-    exceptionHandled = FALSE;
-
-    LOG_TRACE_EXCEPTION("Exception: 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
-
-    // now even if we don't have an error code
-    // our ISRs push a zero on the stack
-    ASSERT(NULL != StackPointer);
-
-    if (ErrorCodeAvailable)
-    {
-        errorCode = (DWORD)StackPointer->ErrorCode;
-    }
-
-    if (ExceptionPageFault == InterruptIndex)
-    {
-        PVOID pfAddr;
-
-        ASSERT(ErrorCodeAvailable);
-
-        pfAddr = __readcr2();
-        LOG_TRACE_EXCEPTION("#PF address: 0x%X\n", pfAddr);
-        exceptionHandled = MmuSolvePageFault(pfAddr, errorCode );
-        if (!exceptionHandled)
-        {
-            PPCPU pCpu;
-
-            pCpu = GetCurrentPcpu();
-            if (NULL != pCpu)
-            {
-                BYTE* pStackBottom;
-
-                pStackBottom = (BYTE*)pCpu->StackTop - pCpu->StackSize;
-
-                if (CHECK_BOUNDS(pfAddr, 1, pStackBottom - STACK_GUARD_SIZE, STACK_GUARD_SIZE))
-                {
-                    // memory accessed is directly below the stack (in the unmapped stack guard area)
-                    LOG_ERROR("Stack overflow\n"
-                              "Stack in range [0x%X, 0x%X]\n"
-                              "#PF is at 0x%X\n",
-                              pStackBottom, pCpu->StackTop,
-                              pfAddr
-                              );
-                }
-            }
-        }
-    }
-    else if (ExceptionGeneralProtection == InterruptIndex)
-    {
-        LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
-    }
-
-    if (!exceptionHandled)
-    {
-        if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
-        {
-            PPROCESS currProcess = GetCurrentProcess();
-            LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
-            ProcessTerminate(currProcess);
-        }
-    }
-
-    // no use in logging if we solved the problem
-    if (!exceptionHandled)
-    {
-        PVOID* pCurrentStackItem;
-        DWORD noOfStackElementsToDump;
-        PPCPU pCpu;
-
-        LOG_ERROR("Could not handle exception 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
-
-        DumpInterruptStack(StackPointer, ErrorCodeAvailable );
-        DumpControlRegisters();
-        DumpProcessorState(ProcessorState);
-
-        LOG("Faulting stack data:\n");
-
-        pCpu = GetCurrentPcpu();
-
-        pCurrentStackItem = (PVOID*) max(StackPointer->Registers.Rsp,
-                                         pCpu != NULL ? (QWORD) PtrDiff(pCpu->StackTop, (QWORD) pCpu->StackSize)
-                                                      : StackPointer->Registers.Rsp);
-        noOfStackElementsToDump = (DWORD) (min(STACK_BYTES_TO_DUMP_ON_EXCEPTION,
-                                               pCpu != NULL ? PtrDiff(pCpu->StackTop,pCurrentStackItem) : STACK_BYTES_TO_DUMP_ON_EXCEPTION)
-                                           / sizeof(PVOID));
-        for (DWORD i = 0; i < noOfStackElementsToDump; ++i)
-        {
-            LOG("[0x%X]: 0x%X\n", &pCurrentStackItem[i], pCurrentStackItem[i]);
-        }
-    }
-
-    ASSERT_INFO(exceptionHandled, "Exception 0x%x was not handled\n", InterruptIndex);
+	DWORD errorCode;
+	BOOLEAN exceptionHandled;
+
+	errorCode = 0;
+	exceptionHandled = FALSE;
+
+	LOG_TRACE_EXCEPTION("Exception: 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
+
+	// now even if we don't have an error code
+	// our ISRs push a zero on the stack
+	ASSERT(NULL != StackPointer);
+
+	if (ErrorCodeAvailable)
+	{
+		errorCode = (DWORD)StackPointer->ErrorCode;
+	}
+
+	if (ExceptionPageFault == InterruptIndex)
+	{
+		PVOID pfAddr;
+
+		ASSERT(ErrorCodeAvailable);
+
+		pfAddr = __readcr2();
+		LOG_TRACE_EXCEPTION("#PF address: 0x%X\n", pfAddr);
+		exceptionHandled = MmuSolvePageFault(pfAddr, errorCode);
+		if (!exceptionHandled)
+		{
+			PPCPU pCpu;
+
+			pCpu = GetCurrentPcpu();
+			if (NULL != pCpu)
+			{
+				BYTE* pStackBottom;
+
+				pStackBottom = (BYTE*)pCpu->StackTop - pCpu->StackSize;
+
+				if (CHECK_BOUNDS(pfAddr, 1, pStackBottom - STACK_GUARD_SIZE, STACK_GUARD_SIZE))
+				{
+					// memory accessed is directly below the stack (in the unmapped stack guard area)
+					LOG_ERROR("Stack overflow\n"
+						"Stack in range [0x%X, 0x%X]\n"
+						"#PF is at 0x%X\n",
+						pStackBottom, pCpu->StackTop,
+						pfAddr
+					);
+				}
+			}
+		}
+	}
+	else if (ExceptionGeneralProtection == InterruptIndex)
+	{
+		LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
+	}
+	if (!exceptionHandled)
+	{
+		if (!GdtIsSegmentPrivileged((WORD)StackPointer->Registers.CS))
+		{
+			PPROCESS currProcess = GetCurrentProcess();
+			LOG_TRACE_EXCEPTION("Terminating process %s\n", ProcessGetName(currProcess));
+			ProcessTerminate(currProcess);
+		}
+	}
+	// no use in logging if we solved the problem
+	if (!exceptionHandled)
+	{
+		PVOID* pCurrentStackItem;
+		DWORD noOfStackElementsToDump;
+		PPCPU pCpu;
+
+		LOG_ERROR("Could not handle exception 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
+
+		DumpInterruptStack(StackPointer, ErrorCodeAvailable);
+		DumpControlRegisters();
+		DumpProcessorState(ProcessorState);
+
+		LOG("Faulting stack data:\n");
+
+		pCpu = GetCurrentPcpu();
+
+		pCurrentStackItem = (PVOID*)max(StackPointer->Registers.Rsp,
+			pCpu != NULL ? (QWORD)PtrDiff(pCpu->StackTop, (QWORD)pCpu->StackSize)
+			: StackPointer->Registers.Rsp);
+		noOfStackElementsToDump = (DWORD)(min(STACK_BYTES_TO_DUMP_ON_EXCEPTION,
+			pCpu != NULL ? PtrDiff(pCpu->StackTop, pCurrentStackItem) : STACK_BYTES_TO_DUMP_ON_EXCEPTION)
+			/ sizeof(PVOID));
+		for (DWORD i = 0; i < noOfStackElementsToDump; ++i)
+		{
+			LOG("[0x%X]: 0x%X\n", &pCurrentStackItem[i], pCurrentStackItem[i]);
+		}
+	}
+
+	ASSERT_INFO(exceptionHandled, "Exception 0x%x was not handled\n", InterruptIndex);
 }
 
 static
 void
 _IsrInterruptHandler(
-    IN BYTE             InterruptIndex
-    )
+	IN BYTE             InterruptIndex
+)
 {
-    BOOLEAN interruptHandled;
-    BOOLEAN bSpuriousInterrupt;
-    BYTE indexInHandlers;
-    IRQL prevIrql;
-
-    interruptHandled = FALSE;
-    indexInHandlers = InterruptIndex - NO_OF_RESERVED_EXCEPTIONS;
-    bSpuriousInterrupt = FALSE;
-
-    // In operating systems that use the lowest priority delivery mode but do not update the TPR, the TPR information
-    // saved in the chipset will potentially cause the interrupt to be always delivered to the same processor from the
-    // logical set. This behavior is functionally backward compatible with the P6 family processor but may result in
-    // unexpected performance implications.
-    prevIrql = CpuMuRaiseIrql(VECTOR_TO_IRQL(InterruptIndex));
-
-    // call registered interrupt
-    if (NULL != m_isrRoutines[indexInHandlers])
-    {
-        interruptHandled = m_isrRoutines[indexInHandlers](m_isrContexts[indexInHandlers]);
-    }
-    else
-    {
-        LOG_ERROR("No interrupt registered for interrupt 0x%x\n", InterruptIndex);
-    }
-
-    if (!interruptHandled)
-    {
-        bSpuriousInterrupt = IomuIsInterruptSpurious(InterruptIndex);
-        if (bSpuriousInterrupt)
-        {
-            LOGP_WARNING("Received spurious vector 0x%02x\n", InterruptIndex);
-        }
-    }
-
-    ASSERT_INFO(interruptHandled || bSpuriousInterrupt, "Interrupt 0x%x was not handled\n", InterruptIndex);
-
-    if (!bSpuriousInterrupt)
-    {
-        // send EOI
-        IomuAckInterrupt(InterruptIndex);
-    }
-
-    // must be called before ThreadYield, else we may lower the IRQL too late or never
-    // if the thread terminates
-    CpuMuLowerIrql(prevIrql);
-
-    if (ThreadYieldOnInterrupt())
-    {
-        ThreadYield();
-    }
+	BOOLEAN interruptHandled;
+	BOOLEAN bSpuriousInterrupt;
+	BYTE indexInHandlers;
+	IRQL prevIrql;
+
+	interruptHandled = FALSE;
+	indexInHandlers = InterruptIndex - NO_OF_RESERVED_EXCEPTIONS;
+	bSpuriousInterrupt = FALSE;
+
+	// In operating systems that use the lowest priority delivery mode but do not update the TPR, the TPR information
+	// saved in the chipset will potentially cause the interrupt to be always delivered to the same processor from the
+	// logical set. This behavior is functionally backward compatible with the P6 family processor but may result in
+	// unexpected performance implications.
+	prevIrql = CpuMuRaiseIrql(VECTOR_TO_IRQL(InterruptIndex));
+
+	// call registered interrupt
+	if (NULL != m_isrRoutines[indexInHandlers])
+	{
+		interruptHandled = m_isrRoutines[indexInHandlers](m_isrContexts[indexInHandlers]);
+	}
+	else
+	{
+		LOG_ERROR("No interrupt registered for interrupt 0x%x\n", InterruptIndex);
+	}
+
+	if (!interruptHandled)
+	{
+		bSpuriousInterrupt = IomuIsInterruptSpurious(InterruptIndex);
+		if (bSpuriousInterrupt)
+		{
+			LOGP_WARNING("Received spurious vector 0x%02x\n", InterruptIndex);
+		}
+	}
+
+	ASSERT_INFO(interruptHandled || bSpuriousInterrupt, "Interrupt 0x%x was not handled\n", InterruptIndex);
+
+	if (!bSpuriousInterrupt)
+	{
+		// send EOI
+		IomuAckInterrupt(InterruptIndex);
+	}
+
+	// must be called before ThreadYield, else we may lower the IRQL too late or never
+	// if the thread terminates
+	CpuMuLowerIrql(prevIrql);
+
+	if (ThreadYieldOnInterrupt())
+	{
+		ThreadYield();
+	}
 }
 
 STATUS
 IsrInstallEx(
-    IN      BYTE                Vector,
-    IN      PFUNC_IsrRoutine    IsrRoutine,
-    IN_OPT  PVOID               Context
-    )
+	IN      BYTE                Vector,
+	IN      PFUNC_IsrRoutine    IsrRoutine,
+	IN_OPT  PVOID               Context
+)
 {
-    BYTE indexInRoutines;
+	BYTE indexInRoutines;
 
-    ASSERT( Vector > NO_OF_RESERVED_EXCEPTIONS);
+	ASSERT(Vector > NO_OF_RESERVED_EXCEPTIONS);
 
-    indexInRoutines = Vector - NO_OF_RESERVED_EXCEPTIONS;
+	indexInRoutines = Vector - NO_OF_RESERVED_EXCEPTIONS;
 
-    if (NULL != m_isrRoutines[indexInRoutines])
-    {
-        LOG_WARNING("There is already a routine installed at vector 0x%x\n", indexInRoutines);
-        return STATUS_ALREADY_INITIALIZED;
-    }
+	if (NULL != m_isrRoutines[indexInRoutines])
+	{
+		LOG_WARNING("There is already a routine installed at vector 0x%x\n", indexInRoutines);
+		return STATUS_ALREADY_INITIALIZED;
+	}
 
-    LOG_TRACE_INTERRUPT("Registering ISR for vector: 0x%x\n", Vector);
-    m_isrRoutines[indexInRoutines] = IsrRoutine;
-    m_isrContexts[indexInRoutines] = Context;
+	LOG_TRACE_INTERRUPT("Registering ISR for vector: 0x%x\n", Vector);
+	m_isrRoutines[indexInRoutines] = IsrRoutine;
+	m_isrContexts[indexInRoutines] = Context;
 
-    return STATUS_SUCCESS;
+	return STATUS_SUCCESS;
 }
diff --git a/src/HAL9000/src/mutex.c b/src/HAL9000/src/mutex.c
index 315a002..57db7e8 100644
--- a/src/HAL9000/src/mutex.c
+++ b/src/HAL9000/src/mutex.c
@@ -55,8 +55,7 @@ MutexAcquire(
 
     while (Mutex->Holder != pCurrentThread)
     {
-        //InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
-        InsertOrderedList(&Mutex->WaitingList, &pCurrentThread->ReadyList, ThreadComparePriorityReadyList, NULL);
+        InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
         ThreadTakeBlockLock();
         LockRelease(&Mutex->MutexLock, dummyState);
         ThreadBlock();
diff --git a/src/HAL9000/src/pmm.c b/src/HAL9000/src/pmm.c
index a064cb4..2347074 100644
--- a/src/HAL9000/src/pmm.c
+++ b/src/HAL9000/src/pmm.c
@@ -3,8 +3,6 @@
 #include "int15.h"
 #include "bitmap.h"
 #include "synch.h"
-#include"thread_internal.h"
-#include "process.h"
 
 typedef struct _MEMORY_REGION_LIST
 {
@@ -182,21 +180,6 @@ PmmReserveMemoryEx(
 
     LockRelease( &m_pmmData.AllocationLock, oldState);
 
-    PTHREAD pThread = GetCurrentThread();
-    PPROCESS pCurrentProcess = NULL;
-    BOOLEAN bSystemProcess;
-
-    if (pThread != NULL)
-    {
-        pCurrentProcess = pThread->Process;
-    }
-
-    bSystemProcess = (pCurrentProcess == NULL) || ProcessIsSystem(pCurrentProcess);
-
-    LOG("Reserved physical frames from 0x%X of size 0x%X on behalf of [%s] process\n",
-        idx * PAGE_SIZE, ((QWORD)NoOfFrames * PAGE_SIZE),
-        bSystemProcess ? "SYSTEM" : ProcessGetName(pCurrentProcess));
-
     return (PHYSICAL_ADDRESS) ( (QWORD) idx * PAGE_SIZE );
 }
 
diff --git a/src/HAL9000/src/process.c b/src/HAL9000/src/process.c
index e8143ad..5bd5695 100644
--- a/src/HAL9000/src/process.c
+++ b/src/HAL9000/src/process.c
@@ -507,6 +507,9 @@ _ProcessInit(
         InitializeListHead(&pProcess->ThreadList);
         LockInit(&pProcess->ThreadListLock);
 
+        InitializeListHead(&pProcess->FrameMappingsHead);
+        LockInit(&pProcess->FrameMapLock);
+
         // Do this as late as possible - we want to interfere as little as possible
         // with the system management in case something goes wrong (PID + full process
         // list management)
diff --git a/src/HAL9000/src/syscall.c b/src/HAL9000/src/syscall.c
index dd42248..a4bceaf 100644
--- a/src/HAL9000/src/syscall.c
+++ b/src/HAL9000/src/syscall.c
@@ -7,8 +7,8 @@
 #include "mmu.h"
 #include "process_internal.h"
 #include "dmp_cpu.h"
-#include "thread.h"
 #include "thread_internal.h"
+#include "thread.h"
 #include "vmm.h"
 
 extern void SyscallEntry();
@@ -17,246 +17,249 @@ extern void SyscallEntry();
 
 void
 SyscallHandler(
-    INOUT   COMPLETE_PROCESSOR_STATE    *CompleteProcessorState
-    )
+	INOUT   COMPLETE_PROCESSOR_STATE* CompleteProcessorState
+)
 {
-    SYSCALL_ID sysCallId;
-    PQWORD pSyscallParameters;
-    PQWORD pParameters;
-    STATUS status;
-    REGISTER_AREA* usermodeProcessorState;
-
-    ASSERT(CompleteProcessorState != NULL);
-
-    // It is NOT ok to setup the FMASK so that interrupts will be enabled when the system call occurs
-    // The issue is that we'll have a user-mode stack and we wouldn't want to receive an interrupt on
-    // that stack. This is why we only enable interrupts here.
-    ASSERT(CpuIntrGetState() == INTR_OFF);
-    CpuIntrSetState(INTR_ON);
-
-    LOG_TRACE_USERMODE("The syscall handler has been called!\n");
-
-    status = STATUS_SUCCESS;
-    pSyscallParameters = NULL;
-    pParameters = NULL;
-    usermodeProcessorState = &CompleteProcessorState->RegisterArea;
-
-    __try
-    {
-        if (LogIsComponentTraced(LogComponentUserMode))
-        {
-            DumpProcessorState(CompleteProcessorState);
-        }
-
-        // Check if indeed the shadow stack is valid (the shadow stack is mandatory)
-        pParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp];
-        status = MmuIsBufferValid(pParameters, SHADOW_STACK_SIZE, PAGE_RIGHTS_READ, GetCurrentProcess());
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("MmuIsBufferValid", status);
-            __leave;
-        }
-
-        sysCallId = usermodeProcessorState->RegisterValues[RegisterR8];
-
-        LOG_TRACE_USERMODE("System call ID is %u\n", sysCallId);
-
-        // The first parameter is the system call ID, we don't care about it => +1
-        pSyscallParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp] + 1;
-
-        // Dispatch syscalls
-        switch (sysCallId)
-        {
-        case SyscallIdIdentifyVersion:
-            status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
-            break;
-        // STUDENT TODO: implement the rest of the syscalls
-        case SyscallIdProcessExit:
-            status = SyscallProcessExit((STATUS)*pSyscallParameters);
-            break;
-        case SyscallIdThreadExit:
-            status = SyscallThreadExit((STATUS)*pSyscallParameters);
-            break;
-        case SyscallIdFileWrite:
-            status = SyscallFileWrite(
-                (UM_HANDLE)pSyscallParameters[0],
-                (PVOID)pSyscallParameters[1],
-                (QWORD)pSyscallParameters[2],
-                (QWORD*)pSyscallParameters[3]
-                );
-            break;
-        case SyscallIdVirtualAlloc:
-            status = SyscallVirtualAlloc(
-                (PVOID)pSyscallParameters[0],
-                (QWORD)pSyscallParameters[1],
-                (VMM_ALLOC_TYPE)pSyscallParameters[2],
-                (PAGE_RIGHTS)pSyscallParameters[3],
-                (UM_HANDLE)pSyscallParameters[4],
-                (QWORD)pSyscallParameters[5],
-                (PVOID)pSyscallParameters[6]
-            );
-            break;
-
-        default:
-            LOG_ERROR("Unimplemented syscall called from User-space!\n");
-            status = STATUS_UNSUPPORTED;
-            break;
-        }
-
-    }
-    __finally
-    {
-        LOG_TRACE_USERMODE("Will set UM RAX to 0x%x\n", status);
-
-        usermodeProcessorState->RegisterValues[RegisterRax] = status;
-
-        CpuIntrSetState(INTR_OFF);
-    }
+	SYSCALL_ID sysCallId;
+	PQWORD pSyscallParameters;
+	PQWORD pParameters;
+	STATUS status;
+	REGISTER_AREA* usermodeProcessorState;
+
+	ASSERT(CompleteProcessorState != NULL);
+
+	// It is NOT ok to setup the FMASK so that interrupts will be enabled when the system call occurs
+	// The issue is that we'll have a user-mode stack and we wouldn't want to receive an interrupt on
+	// that stack. This is why we only enable interrupts here.
+	ASSERT(CpuIntrGetState() == INTR_OFF);
+	CpuIntrSetState(INTR_ON);
+
+	LOG_TRACE_USERMODE("The syscall handler has been called!\n");
+
+	status = STATUS_SUCCESS;
+	pSyscallParameters = NULL;
+	pParameters = NULL;
+	usermodeProcessorState = &CompleteProcessorState->RegisterArea;
+
+	__try
+	{
+		if (LogIsComponentTraced(LogComponentUserMode))
+		{
+			DumpProcessorState(CompleteProcessorState);
+		}
+
+		// Check if indeed the shadow stack is valid (the shadow stack is mandatory)
+		pParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp];
+		status = MmuIsBufferValid(pParameters, SHADOW_STACK_SIZE, PAGE_RIGHTS_READ, GetCurrentProcess());
+		if (!SUCCEEDED(status))
+		{
+			LOG_FUNC_ERROR("MmuIsBufferValid", status);
+			__leave;
+		}
+
+		sysCallId = usermodeProcessorState->RegisterValues[RegisterR8];
+
+		LOG_TRACE_USERMODE("System call ID is %u\n", sysCallId);
+
+		// The first parameter is the system call ID, we don't care about it => +1
+		pSyscallParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp] + 1;
+
+		// Dispatch syscalls
+		switch (sysCallId)
+		{
+		case SyscallIdIdentifyVersion:
+			status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
+			break;
+			// STUDENT TODO: implement the rest of the syscalls
+		case SyscallIdProcessExit:
+			status = SyscallProcessExit((STATUS)*pSyscallParameters);
+			break;
+		case SyscallIdThreadExit:
+			status = SyscallThreadExit((STATUS)*pSyscallParameters);
+			break;
+		case SyscallIdFileWrite:
+			status = SyscallFileWrite(
+				(UM_HANDLE)pSyscallParameters[0],
+				(PVOID)pSyscallParameters[1],
+				(QWORD)pSyscallParameters[2],
+				(QWORD*)pSyscallParameters[3]
+			);
+			break;
+		case SyscallIdVirtualAlloc:
+			status = SyscallVirtualAlloc(
+				(PVOID)pSyscallParameters[0],
+				(QWORD)pSyscallParameters[1],
+				(VMM_ALLOC_TYPE)pSyscallParameters[2],
+				(PAGE_RIGHTS)pSyscallParameters[3],
+				(UM_HANDLE)pSyscallParameters[4],
+				(QWORD)pSyscallParameters[5],
+				(PVOID)pSyscallParameters[6]
+			);
+			break;
+		default:
+			LOG_ERROR("Unimplemented syscall called from User-space!\n");
+			status = STATUS_UNSUPPORTED;
+			break;
+		}
+
+	}
+	__finally
+	{
+		LOG_TRACE_USERMODE("Will set UM RAX to 0x%x\n", status);
+
+		usermodeProcessorState->RegisterValues[RegisterRax] = status;
+
+		CpuIntrSetState(INTR_OFF);
+	}
 }
 
 void
 SyscallPreinitSystem(
-    void
-    )
+	void
+)
 {
 
 }
 
 STATUS
 SyscallInitSystem(
-    void
-    )
+	void
+)
 {
-    return STATUS_SUCCESS;
+	return STATUS_SUCCESS;
 }
 
 STATUS
 SyscallUninitSystem(
-    void
-    )
+	void
+)
 {
-    return STATUS_SUCCESS;
+	return STATUS_SUCCESS;
 }
 
 void
 SyscallCpuInit(
-    void
-    )
+	void
+)
 {
-    IA32_STAR_MSR_DATA starMsr;
-    WORD kmCsSelector;
-    WORD umCsSelector;
+	IA32_STAR_MSR_DATA starMsr;
+	WORD kmCsSelector;
+	WORD umCsSelector;
 
-    memzero(&starMsr, sizeof(IA32_STAR_MSR_DATA));
+	memzero(&starMsr, sizeof(IA32_STAR_MSR_DATA));
 
-    kmCsSelector = GdtMuGetCS64Supervisor();
-    ASSERT(kmCsSelector + 0x8 == GdtMuGetDS64Supervisor());
+	kmCsSelector = GdtMuGetCS64Supervisor();
+	ASSERT(kmCsSelector + 0x8 == GdtMuGetDS64Supervisor());
 
-    umCsSelector = GdtMuGetCS32Usermode();
-    /// DS64 is the same as DS32
-    ASSERT(umCsSelector + 0x8 == GdtMuGetDS32Usermode());
-    ASSERT(umCsSelector + 0x10 == GdtMuGetCS64Usermode());
+	umCsSelector = GdtMuGetCS32Usermode();
+	/// DS64 is the same as DS32
+	ASSERT(umCsSelector + 0x8 == GdtMuGetDS32Usermode());
+	ASSERT(umCsSelector + 0x10 == GdtMuGetCS64Usermode());
 
-    // Syscall RIP <- IA32_LSTAR
-    __writemsr(IA32_LSTAR, (QWORD) SyscallEntry);
+	// Syscall RIP <- IA32_LSTAR
+	__writemsr(IA32_LSTAR, (QWORD)SyscallEntry);
 
-    LOG_TRACE_USERMODE("Successfully set LSTAR to 0x%X\n", (QWORD) SyscallEntry);
+	LOG_TRACE_USERMODE("Successfully set LSTAR to 0x%X\n", (QWORD)SyscallEntry);
 
-    // Syscall RFLAGS <- RFLAGS & ~(IA32_FMASK)
-    __writemsr(IA32_FMASK, RFLAGS_INTERRUPT_FLAG_BIT);
+	// Syscall RFLAGS <- RFLAGS & ~(IA32_FMASK)
+	__writemsr(IA32_FMASK, RFLAGS_INTERRUPT_FLAG_BIT);
 
-    LOG_TRACE_USERMODE("Successfully set FMASK to 0x%X\n", RFLAGS_INTERRUPT_FLAG_BIT);
+	LOG_TRACE_USERMODE("Successfully set FMASK to 0x%X\n", RFLAGS_INTERRUPT_FLAG_BIT);
 
-    // Syscall CS.Sel <- IA32_STAR[47:32] & 0xFFFC
-    // Syscall DS.Sel <- (IA32_STAR[47:32] + 0x8) & 0xFFFC
-    starMsr.SyscallCsDs = kmCsSelector;
+	// Syscall CS.Sel <- IA32_STAR[47:32] & 0xFFFC
+	// Syscall DS.Sel <- (IA32_STAR[47:32] + 0x8) & 0xFFFC
+	starMsr.SyscallCsDs = kmCsSelector;
 
-    // Sysret CS.Sel <- (IA32_STAR[63:48] + 0x10) & 0xFFFC
-    // Sysret DS.Sel <- (IA32_STAR[63:48] + 0x8) & 0xFFFC
-    starMsr.SysretCsDs = umCsSelector;
+	// Sysret CS.Sel <- (IA32_STAR[63:48] + 0x10) & 0xFFFC
+	// Sysret DS.Sel <- (IA32_STAR[63:48] + 0x8) & 0xFFFC
+	starMsr.SysretCsDs = umCsSelector;
 
-    __writemsr(IA32_STAR, starMsr.Raw);
+	__writemsr(IA32_STAR, starMsr.Raw);
 
-    LOG_TRACE_USERMODE("Successfully set STAR to 0x%X\n", starMsr.Raw);
+	LOG_TRACE_USERMODE("Successfully set STAR to 0x%X\n", starMsr.Raw);
 }
 
 // SyscallIdIdentifyVersion
 STATUS
 SyscallValidateInterface(
-    IN  SYSCALL_IF_VERSION          InterfaceVersion
+	IN  SYSCALL_IF_VERSION          InterfaceVersion
 )
 {
-    LOG_TRACE_USERMODE("Will check interface version 0x%x from UM against 0x%x from KM\n",
-        InterfaceVersion, SYSCALL_IF_VERSION_KM);
+	LOG_TRACE_USERMODE("Will check interface version 0x%x from UM against 0x%x from KM\n",
+		InterfaceVersion, SYSCALL_IF_VERSION_KM);
 
-    if (InterfaceVersion != SYSCALL_IF_VERSION_KM)
-    {
-        LOG_ERROR("Usermode interface 0x%x incompatible with KM!\n", InterfaceVersion);
-        return STATUS_INCOMPATIBLE_INTERFACE;
-    }
+	if (InterfaceVersion != SYSCALL_IF_VERSION_KM)
+	{
+		LOG_ERROR("Usermode interface 0x%x incompatible with KM!\n", InterfaceVersion);
+		return STATUS_INCOMPATIBLE_INTERFACE;
+	}
 
-    return STATUS_SUCCESS;
+	return STATUS_SUCCESS;
 }
 
 // STUDENT TODO: implement the rest of the syscalls
 STATUS
-SyscallFileWrite(
-    IN  UM_HANDLE                   FileHandle,
-    IN_READS_BYTES(BytesToWrite)
-     PVOID                       Buffer,
-    IN  QWORD                       BytesToWrite,
-    OUT QWORD * BytesWritten
+SyscallProcessExit(
+	IN      STATUS                  ExitStatus
 )
 {
-    if (BytesWritten == NULL) {
-        return STATUS_UNSUCCESSFUL;
-        
-    }
-    
-    if (FileHandle == UM_FILE_HANDLE_STDOUT) {
-        *BytesWritten = BytesToWrite;
-        LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
-        return STATUS_SUCCESS;
-    }
-    *BytesWritten = BytesToWrite;
-    return STATUS_SUCCESS;
+	PPROCESS Process;
+	Process = GetCurrentProcess();
+	Process->TerminationStatus = ExitStatus;
+	ProcessTerminate(Process);
+	return STATUS_SUCCESS;
+
 }
 
 STATUS
 SyscallThreadExit(
-    IN  STATUS                      ExitStatus
+	IN  STATUS                      ExitStatus
 )
 {
-    ThreadExit(ExitStatus);
-    return STATUS_SUCCESS;
+	ThreadExit(ExitStatus);
+	return STATUS_SUCCESS;
 }
 
 STATUS
-SyscallProcessExit(
-    IN      STATUS                  ExitStatus
+SyscallFileWrite(
+	IN  UM_HANDLE                   FileHandle,
+	IN_READS_BYTES(BytesToWrite)
+	PVOID                       Buffer,
+	IN  QWORD                       BytesToWrite,
+	OUT QWORD* BytesWritten
 )
 {
-    PPROCESS Process;
-    Process = GetCurrentProcess();
-    Process->TerminationStatus = ExitStatus;
-    ProcessTerminate(Process);
-    return STATUS_SUCCESS;
-}
+	if (BytesWritten == NULL) {
+		return STATUS_UNSUCCESSFUL;
+
+	}
+
+	if (FileHandle == UM_FILE_HANDLE_STDOUT) {
 
+		*BytesWritten = BytesToWrite;
+		LOG("[%s]:[%s]\n", ProcessGetName(NULL), Buffer);
+		return STATUS_SUCCESS;
+
+
+	}
+
+	*BytesWritten = BytesToWrite;
+	return STATUS_SUCCESS;
+}
 STATUS
 SyscallVirtualAlloc(
-    IN_OPT      PVOID                   BaseAddress,
-    IN          QWORD                   Size,
-    IN          VMM_ALLOC_TYPE          AllocType,
-    IN          PAGE_RIGHTS             PageRights,
-    IN_OPT      UM_HANDLE               FileHandle,
-    IN_OPT      QWORD                   Key,
-    OUT         PVOID* AllocatedAddress
+	IN_OPT      PVOID                   BaseAddress,
+	IN          QWORD                   Size,
+	IN          VMM_ALLOC_TYPE          AllocType,
+	IN          PAGE_RIGHTS             PageRights,
+	IN_OPT      UM_HANDLE               FileHandle,
+	IN_OPT      QWORD                   Key,
+	OUT         PVOID* AllocatedAddress
 )
 {
-    UNREFERENCED_PARAMETER(Key);
-    UNREFERENCED_PARAMETER(FileHandle)
-    PVOID address = VmmAllocRegionEx(BaseAddress,Size,AllocType,PageRights,FALSE,NULL,NULL,NULL,NULL);
-    *AllocatedAddress = address;
-    return STATUS_SUCCESS;
+	UNREFERENCED_PARAMETER(Key);
+	UNREFERENCED_PARAMETER(FileHandle)
+		PVOID address = VmmAllocRegionEx(BaseAddress, Size, AllocType, PageRights, FALSE, NULL, NULL, NULL, NULL);
+	*AllocatedAddress = address;
+	return STATUS_SUCCESS;
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
index 9e03560..4479152 100644
--- a/src/HAL9000/src/system.c
+++ b/src/HAL9000/src/system.c
@@ -21,15 +21,14 @@
 #include "ex_system.h"
 #include "process_internal.h"
 #include "boot_module.h"
-#include "ex_timer.h"
 
 #define NO_OF_TSS_STACKS             7
 STATIC_ASSERT(NO_OF_TSS_STACKS <= NO_OF_IST);
 
 typedef struct _SYSTEM_DATA
 {
-    BYTE        NumberOfTssStacks;
-} SYSTEM_DATA, *PSYSTEM_DATA;
+	BYTE        NumberOfTssStacks;
+} SYSTEM_DATA, * PSYSTEM_DATA;
 
 static SYSTEM_DATA m_systemData;
 
@@ -37,302 +36,295 @@ QWORD gVirtualToPhysicalOffset;
 
 void
 SystemPreinit(
-    void
-    )
+	void
+)
 {
-    memzero(&m_systemData, sizeof(SYSTEM_DATA));
-
-    m_systemData.NumberOfTssStacks = NO_OF_TSS_STACKS;
-
-    BootModulesPreinit();
-    DumpPreinit();
-    ThreadSystemPreinit();
-    printSystemPreinit(NULL);
-    LogSystemPreinit();
-    OsInfoPreinit();
-    MmuPreinitSystem();
-    IomuPreinitSystem();
-    AcpiInterfacePreinit();
-    SmpPreinit();
-    PciSystemPreinit();
-    CorePreinit();
-    NetworkStackPreinit();
-    ProcessSystemPreinit();
-    ExTimerSystemPreinit();
+	memzero(&m_systemData, sizeof(SYSTEM_DATA));
+
+	m_systemData.NumberOfTssStacks = NO_OF_TSS_STACKS;
+
+	BootModulesPreinit();
+	DumpPreinit();
+	ThreadSystemPreinit();
+	printSystemPreinit(NULL);
+	LogSystemPreinit();
+	OsInfoPreinit();
+	MmuPreinitSystem();
+	IomuPreinitSystem();
+	AcpiInterfacePreinit();
+	SmpPreinit();
+	PciSystemPreinit();
+	CorePreinit();
+	NetworkStackPreinit();
+	ProcessSystemPreinit();
 }
 
 STATUS
 SystemInit(
-    IN  ASM_PARAMETERS*     Parameters
-    )
+	IN  ASM_PARAMETERS* Parameters
+)
 {
-    STATUS status;
-    PCPU* pCpu;
-
-    status = STATUS_SUCCESS;
-    pCpu = NULL;
-
-    /*LogSystemInit(LogLevelError,
-                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                  TRUE
-                  );
-                  */
-    LogSystemInit(LogLevelInfo,
-        LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode | LogComponentMmu,
-        TRUE
-    );
-
-    // if validation fails => the system will HALT
-    CpuMuValidateConfiguration();
-
-    HalInitialize();
-
-    // install new GDT table
-    status = GdtMuInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("GdtMuInit", status);
-        return status;
-    }
-
-    // initialize serial communication
-    status = SerialCommunicationInitialize(Parameters->BiosSerialPorts, BIOS_MAX_NO_OF_SERIAL_PORTS);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("SerialCommunicationInitialize", status);
-        return status;
-    }
-
-    LOG("Serial communications initialized\n");
-    LOG("Running HAL9000 %s version %s built on %s\n",
-        OsGetBuildType(),
-        OsGetVersion(),
-        OsGetBuildDate()
-        );
-
-    status = OsInfoInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("OsInfoInit", status);
-        return status;
-    }
-
-    LOGL("OsInfoInit succeeded\n");
-
-    status = CpuMuActivateFpuFeatures();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
-        return status;
-    }
-
-    LOGL("CpuMuActivateFpuFeatures succeeded\n");
-
-    // IDT handlers need to be initialized before
-    // MmuInitSystem is called because the VMM
-    // needs page fault handling to allocate memory
-    status = InitIdtHandlers(GdtMuGetCS64Supervisor(), 0);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("InitIdtHandlers", status);
-        return status;
-    }
-
-    LOGL("InitIdtHandlers succeeded\n");
-
-    status = MmuInitSystem(Parameters->KernelBaseAddress,
-                           (DWORD) Parameters->KernelSize,
-                           Parameters->MemoryMapAddress,
-                           Parameters->MemoryMapEntries
-                           );
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("MmuInitSystem", status);
-        return status;
-    }
-
-    LOGL("MmuInitSystem succeeded\n");
-
-    if (IsBooleanFlagOn(Parameters->MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
-    {
-        status = BootModulesInit((PHYSICAL_ADDRESS)(QWORD)Parameters->MultibootInformation->ModuleAddress,
-                                Parameters->MultibootInformation->ModuleCount);
-        if (!SUCCEEDED(status))
-        {
-            LOG_FUNC_ERROR("BootModulesMap", status);
-            return status;
-        }
-    }
-
-    status = IomuInitSystemDriver();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("IomuInitSystemDriver", status);
-        return status;
-    }
-    LOGL("IomuInitSystemDriver suceeded\n");
-
-    // initialize ACPI interface
-    status = AcpiInterfaceInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("AcpiInterfaceInit", status);
-        return status;
-    }
-    LOGL("AcpiInterfaceInit suceeded\n");
-
-    status = LapicSystemInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("LapicSystemInit", status);
-        return status;
-    }
-    LOGL("LapicSystemInit suceeded\n");
-
-    status = SmpInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("SmpInit", status);
-        return status;
-    }
-
-    LOGL("SmpInit succeded\n");
-
-    // allocate PCPU structure for the BSP
-    // this needs to be before the call to IomuInitSystem because
-    // by the time we enable interrupts we want our TSS descriptor to be installed
-    status = CpuMuAllocAndInitCpu(&pCpu,
-    // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
+	STATUS status;
+	PCPU* pCpu;
+
+	status = STATUS_SUCCESS;
+	pCpu = NULL;
+
+	LogSystemInit(LogLevelInfo,
+		LogComponentInterrupt | LogComponentIo | LogComponentAcpi | LogComponentUserMode,
+		TRUE
+	);
+
+	// if validation fails => the system will HALT
+	CpuMuValidateConfiguration();
+
+	HalInitialize();
+
+	// install new GDT table
+	status = GdtMuInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("GdtMuInit", status);
+		return status;
+	}
+
+	// initialize serial communication
+	status = SerialCommunicationInitialize(Parameters->BiosSerialPorts, BIOS_MAX_NO_OF_SERIAL_PORTS);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("SerialCommunicationInitialize", status);
+		return status;
+	}
+
+	LOG("Serial communications initialized\n");
+	LOG("Running HAL9000 %s version %s built on %s\n",
+		OsGetBuildType(),
+		OsGetVersion(),
+		OsGetBuildDate()
+	);
+
+	status = OsInfoInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("OsInfoInit", status);
+		return status;
+	}
+
+	LOGL("OsInfoInit succeeded\n");
+
+	status = CpuMuActivateFpuFeatures();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
+		return status;
+	}
+
+	LOGL("CpuMuActivateFpuFeatures succeeded\n");
+
+	// IDT handlers need to be initialized before
+	// MmuInitSystem is called because the VMM
+	// needs page fault handling to allocate memory
+	status = InitIdtHandlers(GdtMuGetCS64Supervisor(), 0);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("InitIdtHandlers", status);
+		return status;
+	}
+
+	LOGL("InitIdtHandlers succeeded\n");
+
+	status = MmuInitSystem(Parameters->KernelBaseAddress,
+		(DWORD)Parameters->KernelSize,
+		Parameters->MemoryMapAddress,
+		Parameters->MemoryMapEntries
+	);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("MmuInitSystem", status);
+		return status;
+	}
+
+	LOGL("MmuInitSystem succeeded\n");
+
+	if (IsBooleanFlagOn(Parameters->MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
+	{
+		status = BootModulesInit((PHYSICAL_ADDRESS)(QWORD)Parameters->MultibootInformation->ModuleAddress,
+			Parameters->MultibootInformation->ModuleCount);
+		if (!SUCCEEDED(status))
+		{
+			LOG_FUNC_ERROR("BootModulesMap", status);
+			return status;
+		}
+	}
+
+	status = IomuInitSystemDriver();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("IomuInitSystemDriver", status);
+		return status;
+	}
+	LOGL("IomuInitSystemDriver suceeded\n");
+
+	// initialize ACPI interface
+	status = AcpiInterfaceInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("AcpiInterfaceInit", status);
+		return status;
+	}
+	LOGL("AcpiInterfaceInit suceeded\n");
+
+	status = LapicSystemInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("LapicSystemInit", status);
+		return status;
+	}
+	LOGL("LapicSystemInit suceeded\n");
+
+	status = SmpInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("SmpInit", status);
+		return status;
+	}
+
+	LOGL("SmpInit succeded\n");
+
+	// allocate PCPU structure for the BSP
+	// this needs to be before the call to IomuInitSystem because
+	// by the time we enable interrupts we want our TSS descriptor to be installed
+	status = CpuMuAllocAndInitCpu(&pCpu,
+		// C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
 #pragma warning(suppress: 28039)
-                                  CpuGetApicId(),
-                                  STACK_DEFAULT_SIZE,
-                                  m_systemData.NumberOfTssStacks
-                                  );
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
-        return status;
-    }
-    LOGL("CpuMuAllocAndInitCpu succeeded\n");
-
-    // initialize IO system
-    // this also initializes the IDT
-    status = IomuInitSystem(GdtMuGetCS64Supervisor(),m_systemData.NumberOfTssStacks );
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("IomuInitSystem", status);
-        return status;
-    }
-
-    LOGL("IomuInitSystem succeeded\n");
-
-    status = CoreInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("CoreInit", status);
-        return status;
-    }
-
-    LOGL("CoreInit succeeded\n");
-
-    status = SmpSetupLowerMemory(m_systemData.NumberOfTssStacks);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("SmpSetupLowerMemory", status);
-        return status;
-    }
-
-    LOGL("SmpSetupLowerMemory succeded\n");
-
-    status = ProcessSystemInitSystemProcess();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("ProcessSystemInitSystemProcess", status);
-        return status;
-    }
-
-    LOGL("Successfully intiialized system process!\n");
-
-    status = ThreadSystemInitIdleForCurrentCPU();
-    LogSetLevel(LogLevelInfo);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-        return status;
-    }
-
-    LOGL("ThreadSystemInitIdleForCurrentCPU succeeded\n");
-
-    status = AcpiInterfaceLateInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("AcpiInterfaceLateInit", status);
-        return status;
-    }
-    LOGL("AcpiInterfaceLateInit succeeded\n");
-
-    SmpWakeupAps();
-    LOGL("SmpWakeupAps completed\n");
-
-    // finish IOMU initialization
-    status = IomuInitSystemAfterApWakeup();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("IomuInitSystemAfterApWakeup", status);
-        return status;
-    }
-    LOGL("IomuInitSystemAfterApWakeup succeeded\n");
-
-    // we no longer need the lower memory mappings
-    SmpCleanupLowerMemory();
-
-    LOGL("SmpCleanupLowerMemory completed\n");
-
-    // After the APs have woken up we no longer need the 1:1 VA->PA mappings
-    MmuDiscardIdentityMappings();
-
-    LOGL("MmuDiscardIdentityMappings completed\n");
-
-    status = MmuInitThreadingSystem();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("MmuInitThreadingSystem", status );
-        return status;
-    }
-
-    LOGL("MmuInitThreadingSystem succeded\n");
-
-    // IOMU late initialization: drivers + system partition determination
-    status = IomuLateInit();
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("IomuLateInit", status);
-        return status;
-    }
-
-    LOGL("IOMU late initialization successfully completed\n");
-
-    status = NetworkStackInit(FALSE);
-    if (!SUCCEEDED(status))
-    {
-        LOG_FUNC_ERROR("NetworkStackInit", status);
-        return status;
-    }
-
-    LOGL("Network stack successfully initialized\n");
-
-    return status;
+		CpuGetApicId(),
+		STACK_DEFAULT_SIZE,
+		m_systemData.NumberOfTssStacks
+	);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
+		return status;
+	}
+	LOGL("CpuMuAllocAndInitCpu succeeded\n");
+
+	// initialize IO system
+	// this also initializes the IDT
+	status = IomuInitSystem(GdtMuGetCS64Supervisor(), m_systemData.NumberOfTssStacks);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("IomuInitSystem", status);
+		return status;
+	}
+
+	LOGL("IomuInitSystem succeeded\n");
+
+	status = CoreInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("CoreInit", status);
+		return status;
+	}
+
+	LOGL("CoreInit succeeded\n");
+
+	status = SmpSetupLowerMemory(m_systemData.NumberOfTssStacks);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("SmpSetupLowerMemory", status);
+		return status;
+	}
+
+	LOGL("SmpSetupLowerMemory succeded\n");
+
+	status = ProcessSystemInitSystemProcess();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("ProcessSystemInitSystemProcess", status);
+		return status;
+	}
+
+	LOGL("Successfully intiialized system process!\n");
+
+	status = ThreadSystemInitIdleForCurrentCPU();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
+		return status;
+	}
+
+	LOGL("ThreadSystemInitIdleForCurrentCPU succeeded\n");
+
+	status = AcpiInterfaceLateInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("AcpiInterfaceLateInit", status);
+		return status;
+	}
+	LOGL("AcpiInterfaceLateInit succeeded\n");
+
+	SmpWakeupAps();
+	LOGL("SmpWakeupAps completed\n");
+
+	// finish IOMU initialization
+	status = IomuInitSystemAfterApWakeup();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("IomuInitSystemAfterApWakeup", status);
+		return status;
+	}
+	LOGL("IomuInitSystemAfterApWakeup succeeded\n");
+
+	// we no longer need the lower memory mappings
+	SmpCleanupLowerMemory();
+
+	LOGL("SmpCleanupLowerMemory completed\n");
+
+	// After the APs have woken up we no longer need the 1:1 VA->PA mappings
+	MmuDiscardIdentityMappings();
+
+	LOGL("MmuDiscardIdentityMappings completed\n");
+
+	status = MmuInitThreadingSystem();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("MmuInitThreadingSystem", status);
+		return status;
+	}
+
+	LOGL("MmuInitThreadingSystem succeded\n");
+
+	// IOMU late initialization: drivers + system partition determination
+	status = IomuLateInit();
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("IomuLateInit", status);
+		return status;
+	}
+
+	LOGL("IOMU late initialization successfully completed\n");
+
+	status = NetworkStackInit(FALSE);
+	if (!SUCCEEDED(status))
+	{
+		LOG_FUNC_ERROR("NetworkStackInit", status);
+		return status;
+	}
+
+	LOGL("Network stack successfully initialized\n");
+
+	return status;
 }
 
 void
 SystemUninit(
-    void
-    )
+	void
+)
 {
-    LOGL("Finished command execution\n");
+	LOGL("Finished command execution\n");
 
-    LOGL("%s terminating!\n", OsInfoGetName());
+	LOGL("%s terminating!\n", OsInfoGetName());
 
-    // disable interrupts
-    CpuIntrDisable();
+	// disable interrupts
+	CpuIntrDisable();
 }
\ No newline at end of file
diff --git a/src/HAL9000/src/test_priority_scheduler.c b/src/HAL9000/src/test_priority_scheduler.c
index 1f78ff4..def79cc 100644
--- a/src/HAL9000/src/test_priority_scheduler.c
+++ b/src/HAL9000/src/test_priority_scheduler.c
@@ -111,7 +111,6 @@ STATUS
     IN_OPT      PVOID       Context
     )
 {
-    LOG("HERE");
     PTEST_PRIORITY_MUTEX_CTX pContext;
     PMUTEX pMutex;
 
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index 63400e4..978f0bd 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -10,10 +10,7 @@
 #include "gdtmu.h"
 #include "pe_exports.h"
 
-#include "smp.h"
-
-
-#define TID_INCREMENT               10
+#define TID_INCREMENT               4
 
 #define THREAD_TIME_SLICE           1
 
@@ -35,17 +32,10 @@ typedef struct _THREAD_SYSTEM_DATA
     _Guarded_by_(AllThreadsLock)
     LIST_ENTRY          AllThreadsList;
 
-    int                 nrOfThreads;
-
     LOCK                ReadyThreadsLock;
 
     _Guarded_by_(ReadyThreadsLock)
     LIST_ENTRY          ReadyThreadsList;
-
-    //added for Threads projects
-    _Guarded_by_(ReadyThreadsLock)
-    THREAD_PRIORITY     RunningThreadsMinPriority;
-
 } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
@@ -131,7 +121,6 @@ _ThreadDereference(
     INOUT   PTHREAD                 Thread
     );
 
-
 static FUNC_FreeFunction            _ThreadDestroy;
 
 static
@@ -153,7 +142,7 @@ ThreadSystemPreinit(
 
     InitializeListHead(&m_threadSystemData.AllThreadsList);
     LockInit(&m_threadSystemData.AllThreadsLock);
-    m_threadSystemData.nrOfThreads = 0;
+
     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
     LockInit(&m_threadSystemData.ReadyThreadsLock);
 }
@@ -181,7 +170,6 @@ ThreadSystemInitMainForCurrentCPU(
     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
 
     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
     if (!SUCCEEDED(status))
     {
         LOG_FUNC_ERROR("_ThreadInit", status );
@@ -490,8 +478,7 @@ ThreadYield(
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
     if (pThread != pCpu->ThreadData.IdleThread)
     {
-        //InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
-        InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList,ThreadComparePriorityReadyList ,NULL);
+        InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
     }
     if (!bForcedYield)
     {
@@ -546,15 +533,10 @@ ThreadUnblock(
     ASSERT(ThreadStateBlocked == Thread->State);
 
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
-    
-    //InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
-    InsertOrderedList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList, ThreadComparePriorityReadyList, NULL);
-    
+    InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
     Thread->State = ThreadStateReady;
     LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
     LockRelease(&Thread->BlockLock, oldState);
-
-    SmpSendGenericIpi(ThreadYieldForIpi, NULL, NULL, NULL, FALSE);
 }
 
 void
@@ -660,9 +642,6 @@ ThreadGetId(
 
     return (NULL != pThread) ? pThread->Id : 0;
 }
-int getNrOfThreads() {
-    return m_threadSystemData.nrOfThreads;
-}
 
 THREAD_PRIORITY
 ThreadGetPriority(
@@ -681,24 +660,7 @@ ThreadSetPriority(
 {
     ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
 
-    INTR_STATE dummyState;
-
-    BOOLEAN shouldYield = FALSE;
-
     GetCurrentThread()->Priority = NewPriority;
-    
-    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
-    PLIST_ENTRY e1 = GetCurrentThread()->ReadyList.Flink;
-    PTHREAD pTh1;
-    pTh1 = CONTAINING_RECORD(e1, THREAD, ReadyList);
-    THREAD_PRIORITY p = ThreadGetPriority(pTh1);
-    if (NewPriority < p) {
-        shouldYield = TRUE;
-    }
-    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState);
-    if (shouldYield) {
-        ThreadYield();
-    }
 }
 
 STATUS
@@ -836,7 +798,6 @@ _ThreadInit(
 
         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-        m_threadSystemData.nrOfThreads++;
         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
     }
     __finally
@@ -849,7 +810,7 @@ _ThreadInit(
                 pThread = NULL;
             }
         }
-        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
+
         *Thread = pThread;
 
         LOG_FUNC_END;
@@ -1227,11 +1188,8 @@ _ThreadDestroy(
     ASSERT(NULL != pThread);
     ASSERT(NULL == Context);
 
-    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-
     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
     RemoveEntryList(&pThread->AllList);
-    m_threadSystemData.nrOfThreads--;
     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
 
     // This must be done before removing the thread from the process list, else
@@ -1281,40 +1239,4 @@ _ThreadKernelFunction(
 
     ThreadExit(exitStatus);
     NOT_REACHED;
-}
-
-INT64
-ThreadComparePriorityReadyList(
-    IN PLIST_ENTRY e1,
-    IN PLIST_ENTRY e2,
-    IN_OPT PVOID Context)
-{
-    UNREFERENCED_PARAMETER(Context);
-    PTHREAD pTh1,pTh2;
-    pTh1 = CONTAINING_RECORD(e1, THREAD, ReadyList);
-    pTh2 = CONTAINING_RECORD(e2, THREAD, ReadyList);
-
-    THREAD_PRIORITY prio1 = ThreadGetPriority(pTh1);
-    THREAD_PRIORITY prio2 = ThreadGetPriority(pTh2);
-
-    if (prio1 < prio2) {
-        return 1;
-    }
-    else if (prio1 > prio2) {
-        return -1;
-    }
-    return 0;
-
-}
-static
-STATUS
-(__cdecl ThreadYieldForIpi)(
-    IN_OPT PVOID Context
-    )
-{
-    UNREFERENCED_PARAMETER(Context);
-    PPCPU pCpu = GetCurrentPcpu();
-    pCpu->ThreadData.YieldOnInterruptReturn = TRUE;
-    //ThreadYield();
-    return STATUS_SUCCESS;
-}
+}
\ No newline at end of file
diff --git a/src/HAL9000/src/vmm.c b/src/HAL9000/src/vmm.c
index f3d9df2..511e9ce 100644
--- a/src/HAL9000/src/vmm.c
+++ b/src/HAL9000/src/vmm.c
@@ -13,6 +13,14 @@
 
 #define VMM_SIZE_FOR_RESERVATION_METADATA            (5*TB_SIZE)
 
+static
+void
+_VmmAddFrameMappings(
+    IN          PHYSICAL_ADDRESS    PhysicalAddress,
+    IN          PVOID               VirtualAddress,
+    IN          DWORD               FrameCount
+);
+
 typedef struct _VMM_DATA
 {
     VMM_RESERVATION_SPACE   VmmReservationSpace;
@@ -65,6 +73,16 @@ typedef struct _VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT
     BOOLEAN                         ClearDirty;
 } VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT, *PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT;
 
+typedef struct _FRAME_MAPPING
+{
+    PHYSICAL_ADDRESS    PhysicalAddress;
+    PVOID               VirtualAddress;
+
+    QWORD               AccessCount;
+
+    LIST_ENTRY          ListEntry;
+} FRAME_MAPPING, * PFRAME_MAPPING;
+
 static VMM_DATA m_vmmData;
 
 static
@@ -269,10 +287,7 @@ VmmMapMemoryInternal(
     ctx.Uncacheable = Uncacheable;
 
     cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
-    if (!_VmIsKernelAddress(BaseAddress)) {
-        LOG("Will map virtual address 0x%X to physical address 0x%X\n",
-            BaseAddress, PhysicalAddress);
-    }
+
     _VmWalkPagingTables(cr3,
                         BaseAddress,
                         Size,
@@ -571,8 +586,6 @@ VmmAllocRegionEx(
             LOG_FUNC_ERROR("VmReservationSpaceAllocRegion", status);
             __leave;
         }
-        LOG("Allocating for VaSpace at 0x%X, a memory region from 0x%X of size 0x%X\n",
-            pVaSpace, pBaseAddress, alignedSize);
         ASSERT(NULL != pBaseAddress);
 
         if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY))
@@ -614,6 +627,11 @@ VmmAllocRegionEx(
                                      PagingData
                 );
 
+                if (PagingData != NULL && !PagingData->Data.KernelSpace)
+                {
+                    _VmmAddFrameMappings(pa, pBaseAddress, noOfFrames);
+                }
+
                 // Check if the mapping is backed up by a file
                 if (FileObject != NULL)
                 {
@@ -731,7 +749,24 @@ VmmFreeRegionEx(
                          alignedSize,
                          Release,
                          PagingData);
+
+
     }
+    PPROCESS currentProcess = GetCurrentProcess();
+    INTR_STATE dummyState;
+    PLIST_ENTRY currentHead = currentProcess->FrameMappingsHead.Blink;
+    LockAcquire(&currentProcess->FrameMapLock, &dummyState);
+    while (currentHead != &currentProcess->FrameMappingsHead) {
+        PFRAME_MAPPING frameMap = CONTAINING_RECORD(currentHead, FRAME_MAPPING, ListEntry);
+        if (frameMap->VirtualAddress == alignedAddress) {
+            MmuUnmapMemoryEx(alignedAddress,
+                alignedSize,
+                Release,
+                PagingData);
+        }
+    }
+    LockRelease(&currentProcess->FrameMapLock, dummyState);
+
 }
 
 BOOLEAN
@@ -819,6 +854,11 @@ VmmSolvePageFault(
                                  PagingData
                                  );
 
+            if (!PagingData->Data.KernelSpace)
+            {
+                _VmmAddFrameMappings(pa, alignedAddress, 1);
+            }
+
             // 3. If the virtual address is backed by a file read its contents
             if (pBackingFile != NULL)
             {
@@ -1375,4 +1415,40 @@ BOOLEAN
     }
 
     return bContinue;
+}
+//lab11
+static
+void
+_VmmAddFrameMappings(
+    IN          PHYSICAL_ADDRESS    PhysicalAddress,
+    IN          PVOID               VirtualAddress,
+    IN          DWORD               FrameCount
+)
+{
+    PPROCESS pProcess;
+    PFRAME_MAPPING pMapping;
+    INTR_STATE intrState;
+
+    pProcess = GetCurrentProcess();
+
+    if (ProcessIsSystem(pProcess))
+    {
+        return;
+    }
+
+    for (DWORD i = 0; i < FrameCount; ++i)
+    {
+        pMapping = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, sizeof(FRAME_MAPPING), HEAP_MMU_TAG, 0);
+
+        pMapping->PhysicalAddress = PtrOffset(PhysicalAddress, i * PAGE_SIZE);
+        pMapping->VirtualAddress = PtrOffset(VirtualAddress, i * PAGE_SIZE);
+        pMapping->AccessCount = 1;
+
+        LockAcquire(&pProcess->FrameMapLock, &intrState);
+        InsertTailList(&pProcess->FrameMappingsHead, &pMapping->ListEntry);
+        LockRelease(&pProcess->FrameMapLock, intrState);
+
+        LOG("Allocated entry from 0x%X -> 0x%X\n",
+            pMapping->VirtualAddress, pMapping->PhysicalAddress);
+    }
 }
\ No newline at end of file
diff --git a/src/Lab2.txt b/src/Lab2.txt
deleted file mode 100644
index a21831e..0000000
--- a/src/Lab2.txt
+++ /dev/null
@@ -1,129 +0,0 @@
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index cec924b..ade0507 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
- set PATH_TO_VM_TOOLS=__EMPTY__
- set VOL_MOUNT_LETTER=__EMPTY__
- 
-+if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
- if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
- if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
- if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
- 
- goto end
- 
-+:config_DESKTOP-6K9VMO8
-+
-+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-+SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-+SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+goto end
-+
- :end
-\ No newline at end of file
-diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-index be2588a..c5c6948 100644
---- a/src/HAL9000/headers/thread_internal.h
-+++ b/src/HAL9000/headers/thread_internal.h
-@@ -282,3 +282,5 @@ void
- ThreadSetPriority(
-     IN      THREAD_PRIORITY     NewPriority
-     );
-+
-+int getNrOfThreads();
-\ No newline at end of file
-diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-index f794c95..d85c26c 100644
---- a/src/HAL9000/src/cmd_thread_helper.c
-+++ b/src/HAL9000/src/cmd_thread_helper.c
-@@ -128,7 +128,7 @@ void
-     STATUS status;
- 
-     ASSERT(NumberOfParameters == 0);
--
-+    LOG("Nr of Threads: %d", getNrOfThreads());
-     LOG("%7s", "TID|");
-     LOG("%20s", "Name|");
-     LOG("%5s", "Prio|");
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index b311f0c..9472327 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -10,7 +10,7 @@
- #include "gdtmu.h"
- #include "pe_exports.h"
- 
--#define TID_INCREMENT               4
-+#define TID_INCREMENT               10
- 
- #define THREAD_TIME_SLICE           1
- 
-@@ -32,6 +32,8 @@ typedef struct _THREAD_SYSTEM_DATA
-     _Guarded_by_(AllThreadsLock)
-     LIST_ENTRY          AllThreadsList;
- 
-+    int                 nrOfThreads;
-+
-     LOCK                ReadyThreadsLock;
- 
-     _Guarded_by_(ReadyThreadsLock)
-@@ -121,6 +123,7 @@ _ThreadDereference(
-     INOUT   PTHREAD                 Thread
-     );
- 
-+
- static FUNC_FreeFunction            _ThreadDestroy;
- 
- static
-@@ -142,7 +145,7 @@ ThreadSystemPreinit(
- 
-     InitializeListHead(&m_threadSystemData.AllThreadsList);
-     LockInit(&m_threadSystemData.AllThreadsLock);
--
-+    m_threadSystemData.nrOfThreads = 0;
-     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-     LockInit(&m_threadSystemData.ReadyThreadsLock);
- }
-@@ -642,6 +645,9 @@ ThreadGetId(
- 
-     return (NULL != pThread) ? pThread->Id : 0;
- }
-+int getNrOfThreads() {
-+    return m_threadSystemData.nrOfThreads;
-+}
- 
- THREAD_PRIORITY
- ThreadGetPriority(
-@@ -798,6 +804,7 @@ _ThreadInit(
- 
-         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-+        m_threadSystemData.nrOfThreads++;
-         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-     }
-     __finally
-@@ -810,7 +817,7 @@ _ThreadInit(
-                 pThread = NULL;
-             }
-         }
--
-+        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-         *Thread = pThread;
- 
-         LOG_FUNC_END;
-@@ -1187,8 +1194,11 @@ _ThreadDestroy(
-     ASSERT(NULL != pThread);
-     ASSERT(NULL == Context);
- 
-+    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-+
-     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-     RemoveEntryList(&pThread->AllList);
-+    m_threadSystemData.nrOfThreads--;
-     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
- 
-     // This must be done before removing the thread from the process list, else
diff --git a/src/Lab3.txt b/src/Lab3.txt
deleted file mode 100644
index 6ef5eee..0000000
--- a/src/Lab3.txt
+++ /dev/null
@@ -1,182 +0,0 @@
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index cec924b..ade0507 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
- set PATH_TO_VM_TOOLS=__EMPTY__
- set VOL_MOUNT_LETTER=__EMPTY__
- 
-+if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
- if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
- if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
- if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
- 
- goto end
- 
-+:config_DESKTOP-6K9VMO8
-+
-+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-+SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-+SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+goto end
-+
- :end
-\ No newline at end of file
-diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-index be2588a..c5c6948 100644
---- a/src/HAL9000/headers/thread_internal.h
-+++ b/src/HAL9000/headers/thread_internal.h
-@@ -282,3 +282,5 @@ void
- ThreadSetPriority(
-     IN      THREAD_PRIORITY     NewPriority
-     );
-+
-+int getNrOfThreads();
-\ No newline at end of file
-diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
-index a7810ff..98b703d 100644
---- a/src/HAL9000/src/Entry64.c
-+++ b/src/HAL9000/src/Entry64.c
-@@ -58,6 +58,8 @@ Entry64(
-     DumpParameters(argv);
- 
-     status = SystemInit(argv);
-+    LogSetLevel(LogLevelTrace);
-+    LogSetTracedComponents(LogComponentThread);
-     ASSERT(SUCCEEDED(status));
- 
-     LOGL("InitSystem executed successfully\n");
-diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-index f794c95..d85c26c 100644
---- a/src/HAL9000/src/cmd_thread_helper.c
-+++ b/src/HAL9000/src/cmd_thread_helper.c
-@@ -128,7 +128,7 @@ void
-     STATUS status;
- 
-     ASSERT(NumberOfParameters == 0);
--
-+    LOG("Nr of Threads: %d", getNrOfThreads());
-     LOG("%7s", "TID|");
-     LOG("%20s", "Name|");
-     LOG("%5s", "Prio|");
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index b0b436e..efc7155 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -70,7 +70,7 @@ SystemInit(
-     status = STATUS_SUCCESS;
-     pCpu = NULL;
- 
--    LogSystemInit(LogLevelInfo,
-+    LogSystemInit(LogLevelError,
-                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                   TRUE
-                   );
-@@ -247,6 +247,7 @@ SystemInit(
-     LOGL("Successfully intiialized system process!\n");
- 
-     status = ThreadSystemInitIdleForCurrentCPU();
-+    LogSetLevel(LogLevelInfo);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index b311f0c..0e9a004 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -10,7 +10,7 @@
- #include "gdtmu.h"
- #include "pe_exports.h"
- 
--#define TID_INCREMENT               4
-+#define TID_INCREMENT               10
- 
- #define THREAD_TIME_SLICE           1
- 
-@@ -32,6 +32,8 @@ typedef struct _THREAD_SYSTEM_DATA
-     _Guarded_by_(AllThreadsLock)
-     LIST_ENTRY          AllThreadsList;
- 
-+    int                 nrOfThreads;
-+
-     LOCK                ReadyThreadsLock;
- 
-     _Guarded_by_(ReadyThreadsLock)
-@@ -121,6 +123,7 @@ _ThreadDereference(
-     INOUT   PTHREAD                 Thread
-     );
- 
-+
- static FUNC_FreeFunction            _ThreadDestroy;
- 
- static
-@@ -142,7 +145,7 @@ ThreadSystemPreinit(
- 
-     InitializeListHead(&m_threadSystemData.AllThreadsList);
-     LockInit(&m_threadSystemData.AllThreadsLock);
--
-+    m_threadSystemData.nrOfThreads = 0;
-     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-     LockInit(&m_threadSystemData.ReadyThreadsLock);
- }
-@@ -169,7 +172,8 @@ ThreadSystemInitMainForCurrentCPU(
- 
-     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
- 
--    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-+    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-+    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("_ThreadInit", status );
-@@ -642,6 +646,9 @@ ThreadGetId(
- 
-     return (NULL != pThread) ? pThread->Id : 0;
- }
-+int getNrOfThreads() {
-+    return m_threadSystemData.nrOfThreads;
-+}
- 
- THREAD_PRIORITY
- ThreadGetPriority(
-@@ -729,7 +736,7 @@ _ThreadInit(
-     LOG_FUNC_START;
- 
-     ASSERT(NULL != Name);
--    ASSERT(NULL != Thread);
-+    //ASSERT(NULL != Thread);
-     ASSERT_INFO(ThreadPriorityLowest <= Priority && Priority <= ThreadPriorityMaximum,
-                 "Priority is 0x%x\n", Priority);
- 
-@@ -798,6 +805,7 @@ _ThreadInit(
- 
-         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-+        m_threadSystemData.nrOfThreads++;
-         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-     }
-     __finally
-@@ -810,7 +818,7 @@ _ThreadInit(
-                 pThread = NULL;
-             }
-         }
--
-+        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-         *Thread = pThread;
- 
-         LOG_FUNC_END;
-@@ -1187,8 +1195,11 @@ _ThreadDestroy(
-     ASSERT(NULL != pThread);
-     ASSERT(NULL == Context);
- 
-+    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-+
-     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-     RemoveEntryList(&pThread->AllList);
-+    m_threadSystemData.nrOfThreads--;
-     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
- 
-     // This must be done before removing the thread from the process list, else
diff --git a/src/Lab4.txt b/src/Lab4.txt
deleted file mode 100644
index dd3af44..0000000
--- a/src/Lab4.txt
+++ /dev/null
@@ -1,206 +0,0 @@
-diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
-index cec924b..ade0507 100644
---- a/postbuild/paths.cmd
-+++ b/postbuild/paths.cmd
-@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
- set PATH_TO_VM_TOOLS=__EMPTY__
- set VOL_MOUNT_LETTER=__EMPTY__
- 
-+if _%COMPUTERNAME%_==_DESKTOP-6K9VMO8_ goto config_DESKTOP-6K9VMO8
- if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
- if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
- if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
-@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
- 
- goto end
- 
-+:config_DESKTOP-6K9VMO8
-+
-+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware VIX"
-+SET PXE_PATH="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\PXE"
-+SET PATH_TO_VM_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
-+SET PATH_TO_LOG_FILE="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.log"
-+SET PATH_TO_VM_DISK="D:\faculta\Anul IV\Semestrul I\OSD\Labs\Lab Materials\HAL9000folder-20221007\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
-+goto end
-+
- :end
-\ No newline at end of file
-diff --git a/src/HAL9000/HAL9000.vcxproj b/src/HAL9000/HAL9000.vcxproj
-index 0dd1641..d8104a5 100644
---- a/src/HAL9000/HAL9000.vcxproj
-+++ b/src/HAL9000/HAL9000.vcxproj
-@@ -366,6 +366,7 @@
-     <ClInclude Include="headers\um_application.h" />
-     <ClInclude Include="headers\vmm.h" />
-     <ClInclude Include="headers\vm_reservation_space.h" />
-+    <ClInclude Include="semaphore.h" />
-   </ItemGroup>
-   <ItemGroup>
-     <YASM Include="src\_mboot32.yasm">
-diff --git a/src/HAL9000/HAL9000.vcxproj.filters b/src/HAL9000/HAL9000.vcxproj.filters
-index f31d483..2275548 100644
---- a/src/HAL9000/HAL9000.vcxproj.filters
-+++ b/src/HAL9000/HAL9000.vcxproj.filters
-@@ -704,6 +704,9 @@
-     <ClInclude Include="headers\test_process.h">
-       <Filter>Header Files\debug\test\userprog</Filter>
-     </ClInclude>
-+    <ClInclude Include="semaphore.h">
-+      <Filter>Header Files\executive</Filter>
-+    </ClInclude>
-   </ItemGroup>
-   <ItemGroup>
-     <None Include="src\defines.yasm">
-diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
-index be2588a..c5c6948 100644
---- a/src/HAL9000/headers/thread_internal.h
-+++ b/src/HAL9000/headers/thread_internal.h
-@@ -282,3 +282,5 @@ void
- ThreadSetPriority(
-     IN      THREAD_PRIORITY     NewPriority
-     );
-+
-+int getNrOfThreads();
-\ No newline at end of file
-diff --git a/src/HAL9000/src/Entry64.c b/src/HAL9000/src/Entry64.c
-index a7810ff..750f290 100644
---- a/src/HAL9000/src/Entry64.c
-+++ b/src/HAL9000/src/Entry64.c
-@@ -58,6 +58,8 @@ Entry64(
-     DumpParameters(argv);
- 
-     status = SystemInit(argv);
-+    //LogSetLevel(LogLevelTrace);
-+    //LogSetTracedComponents(LogComponentThread);
-     ASSERT(SUCCEEDED(status));
- 
-     LOGL("InitSystem executed successfully\n");
-diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
-index f794c95..d85c26c 100644
---- a/src/HAL9000/src/cmd_thread_helper.c
-+++ b/src/HAL9000/src/cmd_thread_helper.c
-@@ -128,7 +128,7 @@ void
-     STATUS status;
- 
-     ASSERT(NumberOfParameters == 0);
--
-+    LOG("Nr of Threads: %d", getNrOfThreads());
-     LOG("%7s", "TID|");
-     LOG("%20s", "Name|");
-     LOG("%5s", "Prio|");
-diff --git a/src/HAL9000/src/system.c b/src/HAL9000/src/system.c
-index b0b436e..efc7155 100644
---- a/src/HAL9000/src/system.c
-+++ b/src/HAL9000/src/system.c
-@@ -70,7 +70,7 @@ SystemInit(
-     status = STATUS_SUCCESS;
-     pCpu = NULL;
- 
--    LogSystemInit(LogLevelInfo,
-+    LogSystemInit(LogLevelError,
-                   LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
-                   TRUE
-                   );
-@@ -247,6 +247,7 @@ SystemInit(
-     LOGL("Successfully intiialized system process!\n");
- 
-     status = ThreadSystemInitIdleForCurrentCPU();
-+    LogSetLevel(LogLevelInfo);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
-diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
-index b311f0c..46ebf9c 100644
---- a/src/HAL9000/src/thread.c
-+++ b/src/HAL9000/src/thread.c
-@@ -10,7 +10,7 @@
- #include "gdtmu.h"
- #include "pe_exports.h"
- 
--#define TID_INCREMENT               4
-+#define TID_INCREMENT               10
- 
- #define THREAD_TIME_SLICE           1
- 
-@@ -32,10 +32,17 @@ typedef struct _THREAD_SYSTEM_DATA
-     _Guarded_by_(AllThreadsLock)
-     LIST_ENTRY          AllThreadsList;
- 
-+    int                 nrOfThreads;
-+
-     LOCK                ReadyThreadsLock;
- 
-     _Guarded_by_(ReadyThreadsLock)
-     LIST_ENTRY          ReadyThreadsList;
-+
-+    //added for Threads projects
-+    _Guarded_by_(ReadyThreadsLock)
-+    THREAD_PRIORITY     RunningThreadsMinPriority;
-+
- } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
- 
- static THREAD_SYSTEM_DATA m_threadSystemData;
-@@ -121,6 +128,7 @@ _ThreadDereference(
-     INOUT   PTHREAD                 Thread
-     );
- 
-+
- static FUNC_FreeFunction            _ThreadDestroy;
- 
- static
-@@ -142,7 +150,7 @@ ThreadSystemPreinit(
- 
-     InitializeListHead(&m_threadSystemData.AllThreadsList);
-     LockInit(&m_threadSystemData.AllThreadsLock);
--
-+    m_threadSystemData.nrOfThreads = 0;
-     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
-     LockInit(&m_threadSystemData.ReadyThreadsLock);
- }
-@@ -170,6 +178,7 @@ ThreadSystemInitMainForCurrentCPU(
-     snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
- 
-     status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
-+    //status = _ThreadInit(mainThreadName, ThreadPriorityDefault, NULL, FALSE);
-     if (!SUCCEEDED(status))
-     {
-         LOG_FUNC_ERROR("_ThreadInit", status );
-@@ -642,6 +651,9 @@ ThreadGetId(
- 
-     return (NULL != pThread) ? pThread->Id : 0;
- }
-+int getNrOfThreads() {
-+    return m_threadSystemData.nrOfThreads;
-+}
- 
- THREAD_PRIORITY
- ThreadGetPriority(
-@@ -798,6 +810,7 @@ _ThreadInit(
- 
-         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
-         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
-+        m_threadSystemData.nrOfThreads++;
-         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
-     }
-     __finally
-@@ -810,7 +823,7 @@ _ThreadInit(
-                 pThread = NULL;
-             }
-         }
--
-+        LOG("Thread with id 0x%X and name %s was created", pThread->Id, pThread->Name);
-         *Thread = pThread;
- 
-         LOG_FUNC_END;
-@@ -1187,8 +1200,11 @@ _ThreadDestroy(
-     ASSERT(NULL != pThread);
-     ASSERT(NULL == Context);
- 
-+    LOG("Thread with id 0x%X and name %s was finished", pThread->Id, pThread->Name);
-+
-     LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
-     RemoveEntryList(&pThread->AllList);
-+    m_threadSystemData.nrOfThreads--;
-     LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
- 
-     // This must be done before removing the thread from the process list, else
diff --git a/src/Lab4_1.txt b/src/Lab4_1.txt
deleted file mode 100644
index e69de29..0000000
diff --git a/src/shared/kernel/thread.h b/src/shared/kernel/thread.h
index 358bb16..acc7153 100644
--- a/src/shared/kernel/thread.h
+++ b/src/shared/kernel/thread.h
@@ -2,7 +2,6 @@
 
 #include "thread_defs.h"
 
-
 //******************************************************************************
 // Function:     ThreadCreate
 // Description:  Spawns a new thread named Name with priority Function which
@@ -41,6 +40,7 @@ void
 ThreadYield(
     void
     );
+
 //******************************************************************************
 // Function:     ThreadExit
 // Description:  Causes the current thread to exit. Never returns.
@@ -119,16 +119,3 @@ THREAD_PRIORITY
 ThreadGetPriority(
     IN_OPT  PTHREAD             Thread
     );
-
-INT64
-ThreadComparePriorityReadyList(
-    IN PLIST_ENTRY e1,
-    IN PLIST_ENTRY e2,
-    IN_OPT PVOID Context
-);
-
-static
-STATUS
-(__cdecl ThreadYieldForIpi)(
-    IN_OPT PVOID Context
-    );
\ No newline at end of file
diff --git a/tests/check_tests.pl b/tests/check_tests.pl
index 0caf372..591ceae 100644
--- a/tests/check_tests.pl
+++ b/tests/check_tests.pl
@@ -44,7 +44,7 @@ sub CheckFile
 
     if (not defined $result)
     {
-        my $checker = open($fh, '<', $checkerFileName) ? (close $fh, "perl \"$checkerFileName\"") : "fc";
+        my $checker = open($fh, '<', $checkerFileName) ? (close $fh, "perl $checkerFileName") : "fc";
 
         # do a compare
         system("$checker \"$resultFileName\" \"$expectedFileName\" > \"$outComefileName\"");
